diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/closure/closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java /mnt/D4JPatches/Manual2023/patches_correct/Closure/Closure_120/Closure_120_Benchmark/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
--- /mnt/d4j_bug_info/buggyfiles/closure/closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java	2022-11-20 04:09:31.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_correct/Closure/Closure_120/Closure_120_Benchmark/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java	2023-11-13 22:37:06.000000000 -0800
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.javascript.jscomp;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -32,7 +31,6 @@
 import com.google.javascript.rhino.jstype.StaticReference;
 import com.google.javascript.rhino.jstype.StaticSourceFile;
 import com.google.javascript.rhino.jstype.StaticSymbolTable;
-
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
@@ -49,17 +47,14 @@
  *
  * @author kushal@google.com (Kushal Dave)
  */
-class ReferenceCollectingCallback implements ScopedCallback,
-    HotSwapCompilerPass,
-    StaticSymbolTable<Var, ReferenceCollectingCallback.Reference> {
+class ReferenceCollectingCallback implements ScopedCallback, HotSwapCompilerPass, StaticSymbolTable<Var, ReferenceCollectingCallback.Reference> {
 
   /**
    * Maps a given variable to a collection of references to that name. Note that
    * Var objects are not stable across multiple traversals (unlike scope root or
    * name).
    */
-  private final Map<Var, ReferenceCollection> referenceMap =
-      Maps.newHashMap();
+    private final Map<Var, ReferenceCollection> referenceMap = Maps.newHashMap();
 
   /**
    * The stack of basic blocks and scopes the current traversal is in.
@@ -94,8 +89,7 @@
    * The test for Var equality uses reference equality, so it's necessary to
    * inject a scope when you traverse.
    */
-  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior,
-      Predicate<Var> varFilter) {
+    ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior, Predicate<Var> varFilter) {
     this.compiler = compiler;
     this.behavior = behavior;
     this.varFilter = varFilter;
@@ -107,8 +101,7 @@
    */
   @Override
   public void process(Node externs, Node root) {
-    NodeTraversal.traverseRoots(
-        compiler, Lists.newArrayList(externs, root), this);
+        NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), this);
   }
 
   /**
@@ -157,7 +150,6 @@
         addReference(v, new Reference(n, t, blockStack.peek()));
       }
     }
-
     if (isBlockBoundary(n, parent)) {
       blockStack.pop();
     }
@@ -192,8 +184,7 @@
    * Updates block stack.
    */
   @Override
-  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
-      Node parent) {
+    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
     // If node is a new basic block, put on basic block stack
     if (isBlockBoundary(n, parent)) {
       blockStack.push(new BasicBlock(blockStack.peek(), n));
@@ -229,10 +220,8 @@
           // The first child of a conditional is not a boundary,
           // but all the rest of the children are.
           return n != parent.getFirstChild();
-
       }
     }
-
     return n.isCase();
   }
 
@@ -243,16 +232,17 @@
       referenceInfo = new ReferenceCollection();
       referenceMap.put(v, referenceInfo);
     }
-
     // Add this particular reference
     referenceInfo.add(reference);
   }
 
   interface ReferenceMap {
+
     ReferenceCollection getReferences(Var var);
   }
 
   private static class ReferenceMapWrapper implements ReferenceMap {
+
     private final Map<Var, ReferenceCollection> referenceMap;
 
     public ReferenceMapWrapper(Map<Var, ReferenceCollection> referenceMap) {
@@ -270,6 +260,7 @@
    * utilizes the built-up reference information.
    */
   interface Behavior {
+
     /**
      * Called after we finish with a scope.
      */
@@ -277,8 +268,10 @@
   }
 
   static final Behavior DO_NOTHING_BEHAVIOR = new Behavior() {
+
     @Override
-    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {}
+        public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {
+        }
   };
 
   /**
@@ -312,23 +305,19 @@
       if (size == 0) {
         return false;
       }
-
       // If this is a declaration that does not instantiate the variable,
       // it's not well-defined.
       Reference init = getInitializingReference();
       if (init == null) {
         return false;
       }
-
       Preconditions.checkState(references.get(0).isDeclaration());
       BasicBlock initBlock = init.getBasicBlock();
       for (int i = 1; i < size; i++) {
-        if (!initBlock.provablyExecutesBefore(
-                references.get(i).getBasicBlock())) {
+                if (!initBlock.provablyExecutesBefore(references.get(i).getBasicBlock())) {
           return false;
         }
       }
-
       return true;
     }
 
@@ -423,17 +412,17 @@
       if (ref == null) {
         return false;
       }
-
       // Make sure this assignment is not in a loop.
-      for (BasicBlock block = ref.getBasicBlock();
-           block != null; block = block.getParent()) {
+            for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
         if (block.isFunction) {
+                    if (ref.getSymbol().getScope() != ref.scope) {
+                        return false;
+                    }
           break;
         } else if (block.isLoop) {
           return false;
         }
       }
-
       return true;
     }
 
@@ -485,26 +474,26 @@
    */
   static final class Reference implements StaticReference<JSType> {
 
-    private static final Set<Integer> DECLARATION_PARENTS =
-        ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH);
+        private static final Set<Integer> DECLARATION_PARENTS = ImmutableSet.of(Token.VAR, Token.FUNCTION, Token.CATCH);
 
     private final Node nameNode;
+
     private final BasicBlock basicBlock;
+
     private final Scope scope;
+
     private final InputId inputId;
+
     private final StaticSourceFile sourceFile;
 
-    Reference(Node nameNode, NodeTraversal t,
-        BasicBlock basicBlock) {
+        Reference(Node nameNode, NodeTraversal t, BasicBlock basicBlock) {
       this(nameNode, basicBlock, t.getScope(), t.getInput().getInputId());
     }
 
     // Bleeding functions are weird, because the declaration does
     // not appear inside their scope. So they need their own constructor.
-    static Reference newBleedingFunction(NodeTraversal t,
-        BasicBlock basicBlock, Node func) {
-      return new Reference(func.getFirstChild(),
-          basicBlock, t.getScope(), t.getInput().getInputId());
+        static Reference newBleedingFunction(NodeTraversal t, BasicBlock basicBlock, Node func) {
+            return new Reference(func.getFirstChild(), basicBlock, t.getScope(), t.getInput().getInputId());
     }
 
     /**
@@ -514,12 +503,10 @@
      */
     @VisibleForTesting
     static Reference createRefForTest(CompilerInput input) {
-      return new Reference(new Node(Token.NAME), null, null,
-          input.getInputId());
+            return new Reference(new Node(Token.NAME), null, null, input.getInputId());
     }
 
-    private Reference(Node nameNode,
-        BasicBlock basicBlock, Scope scope, InputId inputId) {
+        private Reference(Node nameNode, BasicBlock basicBlock, Scope scope, InputId inputId) {
       this.nameNode = nameNode;
       this.basicBlock = basicBlock;
       this.scope = scope;
@@ -556,9 +543,7 @@
     boolean isDeclaration() {
       Node parent = getParent();
       Node grandparent = parent.getParent();
-      return DECLARATION_PARENTS.contains(parent.getType()) ||
-          parent.isParamList() &&
-          grandparent.isFunction();
+            return DECLARATION_PARENTS.contains(parent.getType()) || parent.isParamList() && grandparent.isFunction();
     }
 
     boolean isVarDeclaration() {
@@ -575,9 +560,7 @@
     boolean isInitializingDeclaration() {
       // VAR is the only type of variable declaration that may not initialize
       // its variable. Catch blocks, named functions, and parameters all do.
-      return isDeclaration() &&
-          !getParent().isVar() ||
-          nameNode.getFirstChild() != null;
+            return isDeclaration() && !getParent().isVar() || nameNode.getFirstChild() != null;
     }
 
    /**
@@ -586,8 +569,7 @@
     */
     Node getAssignedValue() {
       Node parent = getParent();
-      return (parent.isFunction())
-          ? parent : NodeUtil.getAssignedValue(nameNode);
+            return (parent.isFunction()) ? parent : NodeUtil.getAssignedValue(nameNode);
     }
 
     BasicBlock getBasicBlock() {
@@ -613,19 +595,13 @@
 
     boolean isSimpleAssignmentToName() {
       Node parent = getParent();
-      return parent.isAssign()
-          && parent.getFirstChild() == nameNode;
+            return parent.isAssign() && parent.getFirstChild() == nameNode;
     }
 
     boolean isLvalue() {
       Node parent = getParent();
       int parentType = parent.getType();
-      return (parentType == Token.VAR && nameNode.getFirstChild() != null)
-          || parentType == Token.INC
-          || parentType == Token.DEC
-          || (NodeUtil.isAssignmentOp(parent)
-              && parent.getFirstChild() == nameNode)
-          || isLhsOfForInExpression(nameNode);
+            return (parentType == Token.VAR && nameNode.getFirstChild() != null) || parentType == Token.INC || parentType == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == nameNode) || isLhsOfForInExpression(nameNode);
     }
 
     Scope getScope() {
@@ -664,17 +640,12 @@
      */
     BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
-
       // only named functions may be hoisted.
       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
-
       this.isFunction = root.isFunction();
-
       if (root.getParent() != null) {
         int pType = root.getParent().getType();
-        this.isLoop = pType == Token.DO ||
-            pType == Token.WHILE ||
-            pType == Token.FOR;
+                this.isLoop = pType == Token.DO || pType == Token.WHILE || pType == Token.FOR;
       } else {
         this.isLoop = false;
       }
@@ -704,14 +675,11 @@
       // If thatBlock is a descendant of this block, and there are no hoisted
       // blocks between them, then this block must start before thatBlock.
       BasicBlock currentBlock;
-      for (currentBlock = thatBlock;
-           currentBlock != null && currentBlock != this;
-           currentBlock = currentBlock.getParent()) {
+            for (currentBlock = thatBlock; currentBlock != null && currentBlock != this; currentBlock = currentBlock.getParent()) {
         if (currentBlock.isHoisted) {
           return false;
         }
       }
-
       if (currentBlock == this) {
         return true;
       }

diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/closure/closure_31_buggy/src/com/google/javascript/jscomp/Compiler.java /mnt/D4JPatches/Manual2023/patches_correct/Closure/Closure_31/Closure_31_Jaid/src/com/google/javascript/jscomp/Compiler.java
--- /mnt/d4j_bug_info/buggyfiles/closure/closure_31_buggy/src/com/google/javascript/jscomp/Compiler.java	2022-11-20 04:09:31.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_correct/Closure/Closure_31/Closure_31_Jaid/src/com/google/javascript/jscomp/Compiler.java	2023-11-13 22:37:06.000000000 -0800
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.javascript.jscomp;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -43,7 +42,6 @@
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.head.ErrorReporter;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
-
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintStream;
@@ -72,19 +70,14 @@
  * External variables are declared in 'externs' files. For instance, the file
  * may include definitions for global javascript/browser objects such as
  * window, document.
- *
  */
 public class Compiler extends AbstractCompiler {
+
   static final String SINGLETON_MODULE_NAME = "[singleton]";
 
-  static final DiagnosticType MODULE_DEPENDENCY_ERROR =
-      DiagnosticType.error("JSC_MODULE_DEPENDENCY_ERROR",
-          "Bad dependency: {0} -> {1}. "
-              + "Modules must be listed in dependency order.");
-
-  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(
-      "JSC_MISSING_ENTRY_ERROR",
-      "required entry point \"{0}\" never provided");
+    static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error("JSC_MODULE_DEPENDENCY_ERROR", "Bad dependency: {0} -> {1}. " + "Modules must be listed in dependency order.");
+
+    static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error("JSC_MISSING_ENTRY_ERROR", "required entry point \"{0}\" never provided");
 
   CompilerOptions options = null;
 
@@ -115,15 +108,21 @@
 
   // Parse tree root nodes
   Node externsRoot;
+
   Node jsRoot;
+
   Node externAndJsRoot;
 
   private Map<InputId, CompilerInput> inputsById;
 
-  /** The source code map */
+    /**
+     * The source code map
+     */
   private SourceMap sourceMap;
 
-  /** The externs created from the exports.  */
+    /**
+     * The externs created from the exports.
+     */
   private String externExports = null;
 
   /**
@@ -132,7 +131,9 @@
    */
   private int uniqueNameId = 0;
 
-  /** Whether to use threads. */
+    /**
+     * Whether to use threads.
+     */
   private boolean useThreads = true;
 
   /**
@@ -141,49 +142,52 @@
    */
   private boolean hasRegExpGlobalReferences = true;
 
-  /** The function information map */
+    /**
+     * The function information map
+     */
   private FunctionInformationMap functionInformationMap;
 
-  /** Debugging information */
+    /**
+     * Debugging information
+     */
   private final StringBuilder debugLog = new StringBuilder();
 
-  /** Detects Google-specific coding conventions. */
+    /**
+     * Detects Google-specific coding conventions.
+     */
   CodingConvention defaultCodingConvention = new ClosureCodingConvention();
 
   private JSTypeRegistry typeRegistry;
+
   private Config parserConfig = null;
 
   private ReverseAbstractInterpreter abstractInterpreter;
+
   private TypeValidator typeValidator;
 
   public PerformanceTracker tracker;
 
   // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.
-  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =
-      RhinoErrorReporter.forOldRhino(this);
+    private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this);
 
   // This error reporter gets the messages from the current Rhino parser.
-  private final ErrorReporter defaultErrorReporter =
-      RhinoErrorReporter.forNewRhino(this);
+    private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this);
+
+    /**
+     * Error strings used for reporting JSErrors
+     */
+    public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error("JSC_OPTIMIZE_LOOP_ERROR", "Exceeded max number of optimization iterations: {0}");
 
-  /** Error strings used for reporting JSErrors */
-  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(
-      "JSC_OPTIMIZE_LOOP_ERROR",
-      "Exceeded max number of optimization iterations: {0}");
-  public static final DiagnosticType MOTION_ITERATIONS_ERROR =
-      DiagnosticType.error("JSC_OPTIMIZE_LOOP_ERROR",
-          "Exceeded max number of code motion iterations: {0}");
+    public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error("JSC_OPTIMIZE_LOOP_ERROR", "Exceeded max number of code motion iterations: {0}");
 
   private static final long COMPILER_STACK_SIZE = 1048576L;
 
-
   /**
    * Logger for the whole com.google.javascript.jscomp domain -
    * setting configuration for this logger affects all loggers
    *  in other classes within the compiler.
    */
-  private static final Logger logger =
-      Logger.getLogger("com.google.javascript.jscomp");
+    private static final Logger logger = Logger.getLogger("com.google.javascript.jscomp");
 
   private final PrintStream outStream;
 
@@ -221,8 +225,7 @@
    * @param errorManager the error manager, it cannot be {@code null}
    */
   public void setErrorManager(ErrorManager errorManager) {
-    Preconditions.checkNotNull(
-        errorManager, "the error manager cannot be null");
+        Preconditions.checkNotNull(errorManager, "the error manager cannot be null");
     this.errorManager = errorManager;
   }
 
@@ -243,16 +246,13 @@
     this.options = options;
     if (errorManager == null) {
       if (outStream == null) {
-        setErrorManager(
-            new LoggerErrorManager(createMessageFormatter(), logger));
+                setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));
       } else {
-        PrintStreamErrorManager printer =
-            new PrintStreamErrorManager(createMessageFormatter(), outStream);
+                PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);
         printer.setSummaryDetailLevel(options.summaryDetailLevel);
         setErrorManager(printer);
       }
     }
-
     // DiagnosticGroups override the plain checkTypes option.
     if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
       options.checkTypes = true;
@@ -262,69 +262,45 @@
       // If DiagnosticGroups did not override the plain checkTypes
       // option, and checkTypes is enabled, then turn off the
       // parser type warnings.
-      options.setWarningLevel(
-          DiagnosticGroup.forType(
-              RhinoErrorReporter.TYPE_PARSE_ERROR),
-          CheckLevel.OFF);
+            options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);
     }
-
-    if (options.checkGlobalThisLevel.isOn() &&
-        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
-      options.setWarningLevel(
-          DiagnosticGroups.GLOBAL_THIS,
-          options.checkGlobalThisLevel);
+        if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
+            options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);
     }
-
     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
-      options.setWarningLevel(
-          DiagnosticGroups.ES5_STRICT,
-          CheckLevel.ERROR);
+            options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);
     }
-
     // Initialize the warnings guard.
     List<WarningsGuard> guards = Lists.newArrayList();
-    guards.add(
-        new SuppressDocWarningsGuard(
-            getDiagnosticGroups().getRegisteredGroups()));
+        guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));
     guards.add(options.getWarningsGuard());
-
     ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);
-
     // All passes must run the variable check. This synthesizes
     // variables later so that the compiler doesn't crash. It also
     // checks the externs file for validity. If you don't want to warn
     // about missing variable declarations, we shut that specific
     // error off.
-    if (!options.checkSymbols &&
-        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
-      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
+        if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
+            composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
     }
-
     this.warningsGuard = composedGuards;
   }
 
   /**
    * Initializes the instance state needed for a compile job.
    */
-  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,
-      CompilerOptions options) {
-    init(Lists.<JSSourceFile>newArrayList(externs),
-        Lists.<JSSourceFile>newArrayList(inputs), options);
+    public void init(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
+        init(Lists.<JSSourceFile>newArrayList(externs), Lists.<JSSourceFile>newArrayList(inputs), options);
   }
 
   /**
    * Initializes the instance state needed for a compile job.
    */
-  public <T1 extends SourceFile, T2 extends SourceFile> void init(
-      List<T1> externs,
-      List<T2> inputs,
-      CompilerOptions options) {
+    public <T1 extends SourceFile, T2 extends SourceFile> void init(List<T1> externs, List<T2> inputs, CompilerOptions options) {
     JSModule module = new JSModule(SINGLETON_MODULE_NAME);
     for (SourceFile input : inputs) {
       module.add(input);
     }
-
     initModules(externs, Lists.newArrayList(module), options);
   }
 
@@ -332,25 +308,19 @@
    * Initializes the instance state needed for a compile job if the sources
    * are in modules.
    */
-  public void init(JSSourceFile[] externs, JSModule[] modules,
-      CompilerOptions options) {
-    initModules(Lists.<SourceFile>newArrayList(externs),
-         Lists.<JSModule>newArrayList(modules), options);
+    public void init(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
+        initModules(Lists.<SourceFile>newArrayList(externs), Lists.<JSModule>newArrayList(modules), options);
   }
 
   /**
    * Initializes the instance state needed for a compile job if the sources
    * are in modules.
    */
-  public <T extends SourceFile> void initModules(
-      List<T> externs, List<JSModule> modules, CompilerOptions options) {
+    public <T extends SourceFile> void initModules(List<T> externs, List<JSModule> modules, CompilerOptions options) {
     initOptions(options);
-
     checkFirstModule(modules);
     fillEmptyModules(modules);
-
     this.externs = makeCompilerInput(externs, true);
-
     // Generate the module graph, and report any errors in the module
     // specification as errors.
     this.modules = modules;
@@ -360,17 +330,14 @@
       } catch (JSModuleGraph.ModuleDependenceException e) {
         // problems with the module format.  Report as an error.  The
         // message gives all details.
-        report(JSError.make(MODULE_DEPENDENCY_ERROR,
-                e.getModule().getName(), e.getDependentModule().getName()));
+                report(JSError.make(MODULE_DEPENDENCY_ERROR, e.getModule().getName(), e.getDependentModule().getName()));
         return;
       }
     } else {
       this.moduleGraph = null;
     }
-
     this.inputs = getAllInputsFromModules(modules);
     initBasedOnOptions();
-
     initInputsByIdMap();
   }
 
@@ -385,8 +352,7 @@
     }
   }
 
-  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(
-      List<T> files, boolean isExtern) {
+    private <T extends SourceFile> List<CompilerInput> makeCompilerInput(List<T> files, boolean isExtern) {
     List<CompilerInput> inputs = Lists.newArrayList();
     for (T file : files) {
       inputs.add(new CompilerInput(file, isExtern));
@@ -394,13 +360,9 @@
     return inputs;
   }
 
-  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =
-      DiagnosticType.error("JSC_EMPTY_MODULE_LIST_ERROR",
-          "At least one module must be provided");
-
-  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =
-      DiagnosticType.error("JSC_EMPTY_ROOT_MODULE_ERROR",
-          "Root module '{0}' must contain at least one source code input");
+    private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error("JSC_EMPTY_MODULE_LIST_ERROR", "At least one module must be provided");
+
+    private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error("JSC_EMPTY_ROOT_MODULE_ERROR", "Root module '{0}' must contain at least one source code input");
 
   /**
    * Verifies that at least one module has been provided and that the first one
@@ -411,8 +373,7 @@
       report(JSError.make(EMPTY_MODULE_LIST_ERROR));
     } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {
       // The root module may only be empty if there is exactly 1 module.
-      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,
-          modules.get(0).getName()));
+            report(JSError.make(EMPTY_ROOT_MODULE_ERROR, modules.get(0).getName()));
     }
   }
 
@@ -431,8 +392,7 @@
   private static void fillEmptyModules(List<JSModule> modules) {
     for (JSModule module : modules) {
       if (module.getInputs().isEmpty()) {
-        module.add(SourceFile.fromCode(
-            createFillFileName(module.getName()), ""));
+                module.add(SourceFile.fromCode(createFillFileName(module.getName()), ""));
       }
     }
   }
@@ -451,14 +411,12 @@
    * Builds a single list of all module inputs. Verifies that it contains no
    * duplicates.
    */
-  private static List<CompilerInput> getAllInputsFromModules(
-      List<JSModule> modules) {
+    private static List<CompilerInput> getAllInputsFromModules(List<JSModule> modules) {
     List<CompilerInput> inputs = Lists.newArrayList();
     Map<String, JSModule> inputMap = Maps.newHashMap();
     for (JSModule module : modules) {
       for (CompilerInput input : module.getInputs()) {
         String inputName = input.getName();
-
         // NOTE(nicksantos): If an input is in more than one module,
         // it will show up twice in the inputs list, and then we
         // will get an error down the line.
@@ -469,11 +427,9 @@
     return inputs;
   }
 
-  static final DiagnosticType DUPLICATE_INPUT =
-      DiagnosticType.error("JSC_DUPLICATE_INPUT", "Duplicate input: {0}");
-  static final DiagnosticType DUPLICATE_EXTERN_INPUT =
-      DiagnosticType.error("JSC_DUPLICATE_EXTERN_INPUT",
-          "Duplicate extern input: {0}");
+    static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error("JSC_DUPLICATE_INPUT", "Duplicate input: {0}");
+
+    static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error("JSC_DUPLICATE_EXTERN_INPUT", "Duplicate extern input: {0}");
 
   /**
    * Creates a map to make looking up an input by name fast. Also checks for
@@ -497,41 +453,31 @@
     }
   }
 
-  public Result compile(
-      SourceFile extern, SourceFile input, CompilerOptions options) {
+    public Result compile(SourceFile extern, SourceFile input, CompilerOptions options) {
      return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);
   }
 
-  public Result compile(
-      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {
+    public Result compile(SourceFile extern, JSSourceFile[] input, CompilerOptions options) {
      return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);
   }
 
-  public Result compile(
-      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {
-     return compileModules(
-         Lists.newArrayList(extern), Lists.newArrayList(modules), options);
+    public Result compile(JSSourceFile extern, JSModule[] modules, CompilerOptions options) {
+        return compileModules(Lists.newArrayList(extern), Lists.newArrayList(modules), options);
   }
 
   /**
    * Compiles a list of inputs.
    */
-  public Result compile(JSSourceFile[] externs,
-                        JSSourceFile[] inputs,
-                        CompilerOptions options) {
-    return compile(Lists.<SourceFile>newArrayList(externs),
-        Lists.<SourceFile>newArrayList(inputs),
-        options);
+    public Result compile(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
+        return compile(Lists.<SourceFile>newArrayList(externs), Lists.<SourceFile>newArrayList(inputs), options);
   }
 
   /**
    * Compiles a list of inputs.
    */
-  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(
-      List<T1> externs, List<T2> inputs, CompilerOptions options) {
+    public <T1 extends SourceFile, T2 extends SourceFile> Result compile(List<T1> externs, List<T2> inputs, CompilerOptions options) {
     // The compile method should only be called once.
     Preconditions.checkState(jsRoot == null);
-
     try {
       init(externs, inputs, options);
       if (hasErrors()) {
@@ -548,22 +494,16 @@
   /**
    * Compiles a list of modules.
    */
-  public Result compile(JSSourceFile[] externs,
-                        JSModule[] modules,
-                        CompilerOptions options) {
-    return compileModules(Lists.<SourceFile>newArrayList(externs),
-        Lists.<JSModule>newArrayList(modules),
-        options);
+    public Result compile(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
+        return compileModules(Lists.<SourceFile>newArrayList(externs), Lists.<JSModule>newArrayList(modules), options);
   }
 
   /**
    * Compiles a list of modules.
    */
-  public <T extends SourceFile> Result compileModules(List<T> externs,
-      List<JSModule> modules, CompilerOptions options) {
+    public <T extends SourceFile> Result compileModules(List<T> externs, List<JSModule> modules, CompilerOptions options) {
     // The compile method should only be called once.
     Preconditions.checkState(jsRoot == null);
-
     try {
       initModules(externs, modules, options);
       if (hasErrors()) {
@@ -579,6 +519,7 @@
 
   private Result compile() {
     return runInCompilerThread(new Callable<Result>() {
+
       @Override
       public Result call() throws Exception {
         compileInternal();
@@ -604,19 +545,17 @@
   }
 
   @SuppressWarnings("unchecked")
-  static <T> T runCallable(
-      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
-
+    static <T> T runCallable(final Callable<T> callable, boolean useLargeStackThread, boolean trace) {
     // Under JRE 1.6, the jscompiler overflows the stack when running on some
     // large or complex js code. Here we start a new thread with a larger
     // stack in order to let the compiler do its thing, without having to
     // increase the stack size for *every* thread (which is what -Xss does).
     // Might want to add thread pool support for clients that compile a lot.
-
     final boolean dumpTraceReport = trace;
     final Object[] result = new Object[1];
     final Throwable[] exception = new Throwable[1];
     Runnable runnable = new Runnable() {
+
       @Override
       public void run() {
         try {
@@ -633,7 +572,6 @@
         }
       }
     };
-
     if (useLargeStackThread) {
       Thread th = new Thread(null, runnable, "jscompiler", COMPILER_STACK_SIZE);
       th.start();
@@ -648,12 +586,10 @@
     } else {
       runnable.run();
     }
-
     // Pass on any exception caught by the runnable object.
     if (exception[0] != null) {
       throw new RuntimeException(exception[0]);
     }
-
     return (T) result[0];
   }
 
@@ -666,38 +602,30 @@
     if (hasErrors()) {
       return;
     }
-
     if (!precheck()) {
       return;
     }
-
     if (options.nameAnonymousFunctionsOnly) {
       // TODO(nicksantos): Move this into an instrument() phase maybe?
       check();
       return;
     }
-
     if (!options.skipAllPasses) {
       check();
       if (hasErrors()) {
         return;
       }
-
-      if (options.isExternExportsEnabled()
-          || options.externExportsPath != null) {
+            if (options.isExternExportsEnabled() || options.externExportsPath != null) {
         externExports();
       }
-
       // IDE-mode is defined to stop here, before the heavy rewriting begins.
       if (!options.ideMode) {
         optimize();
       }
     }
-
     if (options.recordFunctionInformation) {
       recordFunctionInformation();
     }
-
     if (options.devMode == DevMode.START_AND_END) {
       runSanityCheck();
     }
@@ -735,7 +663,6 @@
     // the client wanted since he or she probably meant to use their
     // own PassConfig object.
     Preconditions.checkNotNull(passes);
-
     if (this.passes != null) {
       throw new IllegalStateException("this.passes has already been assigned");
     }
@@ -754,11 +681,9 @@
 
   public void check() {
     runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);
-
     // We are currently only interested in check-passes for progress reporting
     // as it is used for IDEs, that's why the maximum progress is set to 1.0.
-    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,
-        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));
+        PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, new PhaseOptimizer.ProgressRange(getProgress(), 1.0));
     if (options.devMode == DevMode.EVERY_PASS) {
       phaseOptimizer.setSanityCheck(sanityCheck);
     }
@@ -767,37 +692,25 @@
     if (hasErrors()) {
       return;
     }
-
     // TODO(nicksantos): clean this up. The flow here is too hard to follow.
     if (options.nameAnonymousFunctionsOnly) {
       return;
     }
-
     if (options.removeTryCatchFinally) {
       removeTryCatchFinally();
     }
-
-    if (options.getTweakProcessing().shouldStrip() ||
-        !options.stripTypes.isEmpty() ||
-        !options.stripNameSuffixes.isEmpty() ||
-        !options.stripTypePrefixes.isEmpty() ||
-        !options.stripNamePrefixes.isEmpty()) {
-      stripCode(options.stripTypes, options.stripNameSuffixes,
-          options.stripTypePrefixes, options.stripNamePrefixes);
+        if (options.getTweakProcessing().shouldStrip() || !options.stripTypes.isEmpty() || !options.stripNameSuffixes.isEmpty() || !options.stripTypePrefixes.isEmpty() || !options.stripNamePrefixes.isEmpty()) {
+            stripCode(options.stripTypes, options.stripNameSuffixes, options.stripTypePrefixes, options.stripNamePrefixes);
     }
-
     runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);
   }
 
   private void externExports() {
     logger.fine("Creating extern file for exports");
     startPass("externExports");
-
     ExternExportsPass pass = new ExternExportsPass(this);
     process(pass);
-
     externExports = pass.getGeneratedExterns();
-
     endPass();
   }
 
@@ -806,8 +719,8 @@
     p.process(externsRoot, jsRoot);
   }
 
-  private final PassFactory sanityCheck =
-      new PassFactory("sanityCheck", false) {
+    private final PassFactory sanityCheck = new PassFactory("sanityCheck", false) {
+
     @Override
     protected CompilerPass createInternal(AbstractCompiler compiler) {
       return new SanityCheck(compiler);
@@ -839,12 +752,10 @@
    * Strips code for smaller compiled code. This is useful for removing debug
    * statements to prevent leaking them publicly.
    */
-  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,
-      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {
+    void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes, Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {
     logger.fine("Strip code");
     startPass("stripCode");
-    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,
-        stripTypePrefixes, stripNamePrefixes);
+        StripCode r = new StripCode(this, stripTypes, stripNameSuffixes, stripTypePrefixes, stripNamePrefixes);
     if (options.getTweakProcessing().shouldStrip()) {
       r.enableTweakStripping();
     }
@@ -869,6 +780,7 @@
   }
 
   private Tracer currentTracer = null;
+
   private String currentPassName = null;
 
   /**
@@ -884,13 +796,11 @@
    * Marks the end of a pass.
    */
   void endPass() {
-    Preconditions.checkState(currentTracer != null,
-        "Tracer should not be null at the end of a pass.");
+        Preconditions.checkState(currentTracer != null, "Tracer should not be null at the end of a pass.");
     stopTracer(currentTracer, currentPassName);
     String passToCheck = currentPassName;
     currentPassName = null;
     currentTracer = null;
-
     maybeSanityCheck();
   }
 
@@ -898,8 +808,7 @@
    * Returns a new tracer for the given pass name.
    */
   Tracer newTracer(String passName) {
-    String comment = passName
-        + (recentChange.hasCodeChanged() ? " on recently changed AST" : "");
+        String comment = passName + (recentChange.hasCodeChanged() ? " on recently changed AST" : "");
     if (options.tracer.isOn()) {
       tracker.recordPassStart(passName);
     }
@@ -918,10 +827,7 @@
    */
   public Result getResult() {
     PassConfig.State state = getPassConfig().getIntermediateState();
-    return new Result(getErrors(), getWarnings(), debugLog.toString(),
-        state.variableMap, state.propertyMap,
-        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,
-        sourceMap, externExports, state.cssNames, state.idGeneratorMap);
+        return new Result(getErrors(), getWarnings(), debugLog.toString(), state.variableMap, state.propertyMap, state.anonymousFunctionNameMap, state.stringMap, functionInformationMap, sourceMap, externExports, state.cssNames, state.idGeneratorMap);
   }
 
   /**
@@ -969,6 +875,7 @@
   Supplier<String> getUniqueNameIdSupplier() {
     final Compiler self = this;
     return new Supplier<String>() {
+
       @Override
       public String get() {
         return String.valueOf(self.nextUniqueNameId());
@@ -978,8 +885,7 @@
 
   @Override
   boolean areNodesEqualForInlining(Node n1, Node n2) {
-    if (options.ambiguateProperties ||
-        options.disambiguateProperties) {
+        if (options.ambiguateProperties || options.disambiguateProperties) {
       // The type based optimizations require that type information is preserved
       // during other optimizations.
       return n1.isEquivalentToTyped(n2);
@@ -991,10 +897,8 @@
   //------------------------------------------------------------------------
   // Inputs
   //------------------------------------------------------------------------
-
   // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler
   // interface, and which ones should always be injected.
-
   @Override
   public CompilerInput getInput(InputId id) {
     return inputsById.get(id);
@@ -1036,7 +940,9 @@
     return inputsById.put(id, input);
   }
 
-  /** Add a source input dynamically. Intended for incremental compilation. */
+    /**
+     * Add a source input dynamically. Intended for incremental compilation.
+     */
   void addIncrementalSourceAst(JsAst ast) {
     InputId id = ast.getInputId();
     Preconditions.checkState(getInput(id) == null, "Duplicate input %s", id.getIdName());
@@ -1059,29 +965,23 @@
     if (newRoot == null) {
       return false;
     }
-
     Node oldRoot = oldInput.getAstRoot(this);
     if (oldRoot != null) {
       oldRoot.getParent().replaceChild(oldRoot, newRoot);
     } else {
       getRoot().getLastChild().addChildToBack(newRoot);
     }
-
     CompilerInput newInput = new CompilerInput(ast);
     putCompilerInput(ast.getInputId(), newInput);
-
     JSModule module = oldInput.getModule();
     if (module != null) {
       module.addAfter(newInput, oldInput);
       module.remove(oldInput);
     }
-
     // Verify the input id is set properly.
-    Preconditions.checkState(
-        newInput.getInputId().equals(oldInput.getInputId()));
+        Preconditions.checkState(newInput.getInputId().equals(oldInput.getInputId()));
     InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();
     Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));
-
     inputs.remove(oldInput);
     return true;
   }
@@ -1099,26 +999,20 @@
   boolean addNewSourceAst(JsAst ast) {
     CompilerInput oldInput = getInput(ast.getInputId());
     if (oldInput != null) {
-      throw new IllegalStateException(
-          "Input already exists: " + ast.getInputId().getIdName());
+            throw new IllegalStateException("Input already exists: " + ast.getInputId().getIdName());
     }
     Node newRoot = ast.getAstRoot(this);
     if (newRoot == null) {
       return false;
     }
-
     getRoot().getLastChild().addChildToBack(newRoot);
-
     CompilerInput newInput = new CompilerInput(ast);
-
     // TODO(tylerg): handle this for multiple modules at some point.
     if (moduleGraph == null && !modules.isEmpty()) {
       // singleton module
       modules.get(0).add(newInput);
     }
-
     putCompilerInput(ast.getInputId(), newInput);
-
     return true;
   }
 
@@ -1151,14 +1045,12 @@
   @SuppressWarnings("unchecked")
   DefaultPassConfig ensureDefaultPassConfig() {
     PassConfig passes = getPassConfig().getBasePassConfig();
-    Preconditions.checkState(passes instanceof DefaultPassConfig,
-        "PassConfigs must eventually delegate to the DefaultPassConfig");
+        Preconditions.checkState(passes instanceof DefaultPassConfig, "PassConfigs must eventually delegate to the DefaultPassConfig");
     return (DefaultPassConfig) passes;
   }
 
   public SymbolTable buildKnownSymbolTable() {
     SymbolTable symbolTable = new SymbolTable(getTypeRegistry());
-
     MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();
     if (typedScopeCreator != null) {
       symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());
@@ -1166,31 +1058,22 @@
     } else {
       symbolTable.findScopes(this, externsRoot, jsRoot);
     }
-
-    GlobalNamespace globalNamespace =
-        ensureDefaultPassConfig().getGlobalNamespace();
+        GlobalNamespace globalNamespace = ensureDefaultPassConfig().getGlobalNamespace();
     if (globalNamespace != null) {
       symbolTable.addSymbolsFrom(globalNamespace);
     }
-
-    ReferenceCollectingCallback refCollector =
-        new ReferenceCollectingCallback(
-            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);
+        ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback(this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);
     NodeTraversal.traverse(this, getRoot(), refCollector);
     symbolTable.addSymbolsFrom(refCollector);
-
-    PreprocessorSymbolTable preprocessorSymbolTable =
-        ensureDefaultPassConfig().getPreprocessorSymbolTable();
+        PreprocessorSymbolTable preprocessorSymbolTable = ensureDefaultPassConfig().getPreprocessorSymbolTable();
     if (preprocessorSymbolTable != null) {
       symbolTable.addSymbolsFrom(preprocessorSymbolTable);
     }
-
     symbolTable.fillNamespaceReferences();
     symbolTable.fillPropertyScopes();
     symbolTable.fillThisReferences(this, externsRoot, jsRoot);
     symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);
     symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);
-
     return symbolTable;
   }
 
@@ -1202,13 +1085,9 @@
   @Override
   public ReverseAbstractInterpreter getReverseAbstractInterpreter() {
     if (abstractInterpreter == null) {
-      ChainableReverseAbstractInterpreter interpreter =
-          new SemanticReverseAbstractInterpreter(
-              getCodingConvention(), getTypeRegistry());
+            ChainableReverseAbstractInterpreter interpreter = new SemanticReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry());
       if (options.closurePass) {
-        interpreter = new ClosureReverseAbstractInterpreter(
-            getCodingConvention(), getTypeRegistry())
-            .append(interpreter).getFirst();
+                interpreter = new ClosureReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()).append(interpreter).getFirst();
       }
       abstractInterpreter = interpreter;
     }
@@ -1226,7 +1105,6 @@
   //------------------------------------------------------------------------
   // Parsing
   //------------------------------------------------------------------------
-
   /**
    * Parses the externs and main inputs.
    *
@@ -1235,7 +1113,6 @@
    */
   Node parseInputs() {
     boolean devMode = options.devMode != DevMode.OFF;
-
     // If old roots exist (we are parsing a second time), detach each of the
     // individual file parse trees.
     if (externsRoot != null) {
@@ -1244,24 +1121,18 @@
     if (jsRoot != null) {
       jsRoot.detachChildren();
     }
-
     // Parse main js sources.
     jsRoot = IR.block();
     jsRoot.setIsSyntheticBlock(true);
-
     externsRoot = IR.block();
     externsRoot.setIsSyntheticBlock(true);
-
     externAndJsRoot = IR.block(externsRoot, jsRoot);
     externAndJsRoot.setIsSyntheticBlock(true);
-
     if (options.tracer.isOn()) {
       tracker = new PerformanceTracker(jsRoot, options.tracer);
       addChangeHandler(tracker.getCodeChangeHandler());
     }
-
     Tracer tracer = newTracer("parseInputs");
-
     try {
       // Parse externs sources.
       for (CompilerInput input : externs) {
@@ -1271,19 +1142,14 @@
         }
         externsRoot.addChildToBack(n);
       }
-
       // Modules inferred in ProcessCommonJS pass.
       if (options.transformAMDToCJSModules || options.processCommonJSModules) {
         processAMDAndCommonJSModules();
       }
-
       // Check if inputs need to be rebuilt from modules.
       boolean staleInputs = false;
-
       // Check if the sources need to be re-ordered.
-      if (options.dependencyOptions.needsManagement() &&
-          !options.skipAllPasses &&
-          options.closurePass) {
+            if (options.dependencyOptions.needsManagement() && !false && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
@@ -1291,39 +1157,29 @@
             getTypeRegistry().forwardDeclareType(provide);
           }
         }
-
         try {
-          inputs =
-              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
-              .manageDependencies(options.dependencyOptions, inputs);
+                    inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);
           staleInputs = true;
         } catch (CircularDependencyException e) {
-          report(JSError.make(
-              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
-
+                    report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));
           // If in IDE mode, we ignore the error and keep going.
           if (hasErrors()) {
             return null;
           }
         } catch (MissingProvideException e) {
-          report(JSError.make(
-              MISSING_ENTRY_ERROR, e.getMessage()));
-
+                    report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));
           // If in IDE mode, we ignore the error and keep going.
           if (hasErrors()) {
             return null;
           }
         }
       }
-
       for (CompilerInput input : inputs) {
         Node n = input.getAstRoot(this);
-
         // Inputs can have a null AST during initial parse.
         if (n == null) {
           continue;
         }
-
         if (n.getJSDocInfo() != null) {
           JSDocInfo info = n.getJSDocInfo();
           if (info.isExterns()) {
@@ -1332,9 +1188,7 @@
             // the externs pile anyways.
             externsRoot.addChildToBack(n);
             input.setIsExtern(true);
-
             input.getModule().remove(input);
-
             externs.add(input);
             staleInputs = true;
           } else if (info.isNoCompile()) {
@@ -1343,40 +1197,30 @@
           }
         }
       }
-
       if (staleInputs) {
         fillEmptyModules(modules);
         rebuildInputsFromModules();
       }
-
       // Build the AST.
       for (CompilerInput input : inputs) {
         Node n = input.getAstRoot(this);
         if (n == null) {
           continue;
         }
-
         if (devMode) {
           runSanityCheck();
           if (hasErrors()) {
             return null;
           }
         }
-
-        if (options.sourceMapOutputPath != null ||
-            options.nameReferenceReportPath != null) {
-
+                if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {
           // Annotate the nodes in the tree with information from the
           // input file. This information is used to construct the SourceMap.
-          SourceInformationAnnotator sia =
-              new SourceInformationAnnotator(
-                  input.getName(), options.devMode != DevMode.OFF);
+                    SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);
           NodeTraversal.traverse(this, n, sia);
         }
-
         jsRoot.addChildToBack(n);
       }
-
       if (hasErrors()) {
         return null;
       }
@@ -1408,8 +1252,7 @@
         new TransformAMDToCJSModule(this).process(null, root);
       }
       if (options.processCommonJSModules) {
-        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,
-            options.commonJSModulePathPrefix);
+                ProcessCommonJSModules cjs = new ProcessCommonJSModules(this, options.commonJSModulePathPrefix);
         cjs.process(null, root);
         JSModule m = cjs.getModule();
         if (m != null) {
@@ -1438,8 +1281,7 @@
       }
       try {
         modules = Lists.newArrayList();
-        for (CompilerInput input : this.moduleGraph.manageDependencies(
-            options.dependencyOptions, inputs)) {
+                for (CompilerInput input : this.moduleGraph.manageDependencies(options.dependencyOptions, inputs)) {
           modules.add(modulesByInput.get(input));
         }
         this.modules = modules;
@@ -1460,8 +1302,7 @@
 
   @Override
   Node parseSyntheticCode(String js) {
-    CompilerInput input = new CompilerInput(
-        SourceFile.fromCode(" [synthetic:" + (++syntheticCodeId) + "] ", js));
+        CompilerInput input = new CompilerInput(SourceFile.fromCode(" [synthetic:" + (++syntheticCodeId) + "] ", js));
     putCompilerInput(input.getInputId(), input);
     return input.getAstRoot(this);
   }
@@ -1490,8 +1331,7 @@
   @Override
   Node parseTestCode(String js) {
     initCompilerOptionsIfTesting();
-    CompilerInput input = new CompilerInput(
-        SourceFile.fromCode("[testcode]", js));
+        CompilerInput input = new CompilerInput(SourceFile.fromCode("[testcode]", js));
     if (inputsById == null) {
       inputsById = Maps.newHashMap();
     }
@@ -1507,12 +1347,12 @@
   //------------------------------------------------------------------------
   // Convert back to source code
   //------------------------------------------------------------------------
-
   /**
    * Converts the main parse tree back to js code.
    */
   public String toSource() {
     return runInCompilerThread(new Callable<String>() {
+
       @Override
       public String call() throws Exception {
         Tracer tracer = newTracer("toSource");
@@ -1520,9 +1360,7 @@
           CodeBuilder cb = new CodeBuilder();
           if (jsRoot != null) {
             int i = 0;
-            for (Node scriptNode = jsRoot.getFirstChild();
-                 scriptNode != null;
-                 scriptNode = scriptNode.getNext()) {
+                        for (Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) {
               toSource(cb, i++, scriptNode);
             }
           }
@@ -1539,6 +1377,7 @@
    */
   public String[] toSourceArray() {
     return runInCompilerThread(new Callable<String[]>() {
+
       @Override
       public String[] call() throws Exception {
         Tracer tracer = newTracer("toSourceArray");
@@ -1565,6 +1404,7 @@
    */
   public String toSource(final JSModule module) {
     return runInCompilerThread(new Callable<String>() {
+
       @Override
       public String call() throws Exception {
         List<CompilerInput> inputs = module.getInputs();
@@ -1576,8 +1416,7 @@
         for (int i = 0; i < numInputs; i++) {
           Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
           if (scriptNode == null) {
-            throw new IllegalArgumentException(
-                "Bad module: " + module.getName());
+                        throw new IllegalArgumentException("Bad module: " + module.getName());
           }
           toSource(cb, i, scriptNode);
         }
@@ -1586,12 +1425,12 @@
     });
   }
 
-
   /**
    * Converts the parse tree for each input in a module back to js code.
    */
   public String[] toSourceArray(final JSModule module) {
     return runInCompilerThread(new Callable<String[]>() {
+
       @Override
       public String[] call() throws Exception {
         List<CompilerInput> inputs = module.getInputs();
@@ -1599,16 +1438,13 @@
         if (numInputs == 0) {
           return new String[0];
         }
-
         String[] sources = new String[numInputs];
         CodeBuilder cb = new CodeBuilder();
         for (int i = 0; i < numInputs; i++) {
           Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
           if (scriptNode == null) {
-            throw new IllegalArgumentException(
-                "Bad module input: " + inputs.get(i).getName());
+                        throw new IllegalArgumentException("Bad module input: " + inputs.get(i).getName());
           }
-
           cb.reset();
           toSource(cb, i, scriptNode);
           sources[i] = cb.toString();
@@ -1625,61 +1461,45 @@
    * within the root's source, they will also be printed in a block comment
    * at the beginning of the output.
    */
-  public void toSource(final CodeBuilder cb,
-                       final int inputSeqNum,
-                       final Node root) {
+    public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
     runInCompilerThread(new Callable<Void>() {
+
       @Override
       public Void call() throws Exception {
         if (options.printInputDelimiter) {
           if ((cb.getLength() > 0) && !cb.endsWith("\n")) {
-            cb.append("\n");  // Make sure that the label starts on a new line
+                        // Make sure that the label starts on a new line
+                        cb.append("\n");
           }
           Preconditions.checkState(root.isScript());
-
           String delimiter = options.inputDelimiter;
-
           String inputName = root.getInputId().getIdName();
           String sourceName = root.getSourceFileName();
           Preconditions.checkState(sourceName != null);
           Preconditions.checkState(!sourceName.isEmpty());
-
-          delimiter = delimiter
-              .replaceAll("%name%", Matcher.quoteReplacement(inputName))
-              .replaceAll("%num%", String.valueOf(inputSeqNum));
-
-          cb.append(delimiter)
-            .append("\n");
-        }
-        if (root.getJSDocInfo() != null &&
-            root.getJSDocInfo().getLicense() != null) {
-          cb.append("/*\n")
-            .append(root.getJSDocInfo().getLicense())
-            .append("*/\n");
+                    delimiter = delimiter.replaceAll("%name%", Matcher.quoteReplacement(inputName)).replaceAll("%num%", String.valueOf(inputSeqNum));
+                    cb.append(delimiter).append("\n");
+                }
+                if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
+                    cb.append("/*\n").append(root.getJSDocInfo().getLicense()).append("*/\n");
         }
-
         // If there is a valid source map, then indicate to it that the current
         // root node's mappings are offset by the given string builder buffer.
         if (options.sourceMapOutputPath != null) {
-          sourceMap.setStartingPosition(
-              cb.getLineIndex(), cb.getColumnIndex());
+                    sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
         }
-
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
         String code = toSource(root, sourceMap, inputSeqNum == 0);
         if (!code.isEmpty()) {
           cb.append(code);
-
           // In order to avoid parse ambiguity when files are concatenated
           // together, all files should end in a semi-colon. Do a quick
           // heuristic check if there's an obvious semi-colon already there.
           int length = code.length();
           char lastChar = code.charAt(length - 1);
-          char secondLastChar = length >= 2 ?
-              code.charAt(length - 2) : '\0';
-          boolean hasSemiColon = lastChar == ';' ||
-              (lastChar == '\n' && secondLastChar == ';');
+                    char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0';
+                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';');
           if (!hasSemiColon) {
             cb.append(";");
           }
@@ -1709,14 +1529,10 @@
     builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
-    builder.setTagAsStrict(firstOutput &&
-        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
+        builder.setTagAsStrict(firstOutput && options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
-
-    Charset charset = options.outputCharset != null ?
-        Charset.forName(options.outputCharset) : null;
+        Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;
     builder.setOutputCharset(charset);
-
     return builder.build();
   }
 
@@ -1725,19 +1541,25 @@
    * StringBuilder except that we also track the number of lines.
    */
   public static class CodeBuilder {
+
     private final StringBuilder sb = new StringBuilder();
+
     private int lineCount = 0;
+
     private int colCount = 0;
 
-    /** Removes all text, but leaves the line count unchanged. */
+        /**
+         * Removes all text, but leaves the line count unchanged.
+         */
     void reset() {
       sb.setLength(0);
     }
 
-    /** Appends the given string to the text buffer. */
+        /**
+         * Appends the given string to the text buffer.
+         */
     CodeBuilder append(String str) {
       sb.append(str);
-
       // Adjust the line and column information for the new text.
       int index = -1;
       int lastIndex = index;
@@ -1745,49 +1567,55 @@
         ++lineCount;
         lastIndex = index;
       }
-
       if (lastIndex == -1) {
         // No new lines, append the new characters added.
         colCount += str.length();
       } else {
         colCount = str.length() - (lastIndex + 1);
       }
-
       return this;
     }
 
-    /** Returns all text in the text buffer. */
+        /**
+         * Returns all text in the text buffer.
+         */
     @Override
     public String toString() {
       return sb.toString();
     }
 
-    /** Returns the length of the text buffer. */
+        /**
+         * Returns the length of the text buffer.
+         */
     public int getLength() {
       return sb.length();
     }
 
-    /** Returns the (zero-based) index of the last line in the text buffer. */
+        /**
+         * Returns the (zero-based) index of the last line in the text buffer.
+         */
     int getLineIndex() {
       return lineCount;
     }
 
-    /** Returns the (zero-based) index of the last column in the text buffer. */
+        /**
+         * Returns the (zero-based) index of the last column in the text buffer.
+         */
     int getColumnIndex() {
       return colCount;
     }
 
-    /** Determines whether the text ends with the given suffix. */
+        /**
+         * Determines whether the text ends with the given suffix.
+         */
     boolean endsWith(String suffix) {
-      return (sb.length() > suffix.length())
-          && suffix.equals(sb.substring(sb.length() - suffix.length()));
+            return (sb.length() > suffix.length()) && suffix.equals(sb.substring(sb.length() - suffix.length()));
     }
   }
 
   //------------------------------------------------------------------------
   // Optimizations
   //------------------------------------------------------------------------
-
   public void optimize() {
     // Ideally, this pass should be the first pass run, however:
     // 1) VariableReferenceCheck reports unexpected warnings if Normalize
@@ -1795,7 +1623,6 @@
     // 2) ReplaceMessages, stripCode, and potentially custom passes rely on
     // unmodified local names.
     normalize();
-
     PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);
     if (options.devMode == DevMode.EVERY_PASS) {
       phaseOptimizer.setSanityCheck(sanityCheck);
@@ -1825,17 +1652,16 @@
    * specifically for that target.
    */
   public void processDefines() {
-    (new DefaultPassConfig(options)).processDefines.create(this)
-        .process(externsRoot, jsRoot);
+        (new DefaultPassConfig(options)).processDefines.create(this).process(externsRoot, jsRoot);
   }
 
   boolean isInliningForbidden() {
-    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||
-        options.propertyRenaming ==
-            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;
+        return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;
   }
 
-  /** Control Flow Analysis. */
+    /**
+     * Control Flow Analysis.
+     */
   ControlFlowGraph<Node> computeCFG() {
     logger.fine("Computing Control Flow Graph");
     Tracer tracer = newTracer("computeCFG");
@@ -1861,20 +1687,19 @@
   void recordFunctionInformation() {
     logger.fine("Recording function information");
     startPass("recordFunctionInformation");
-    RecordFunctionInformation recordFunctionInfoPass =
-        new RecordFunctionInformation(
-            this, getPassConfig().getIntermediateState().functionNames);
+        RecordFunctionInformation recordFunctionInfoPass = new RecordFunctionInformation(this, getPassConfig().getIntermediateState().functionNames);
     process(recordFunctionInfoPass);
     functionInformationMap = recordFunctionInfoPass.getMap();
     endPass();
   }
 
-  protected final CodeChangeHandler.RecentChange recentChange =
-      new CodeChangeHandler.RecentChange();
-  private final List<CodeChangeHandler> codeChangeHandlers =
-      Lists.<CodeChangeHandler>newArrayList();
+    protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange();
+
+    private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList();
 
-  /** Name of the synthetic input that holds synthesized externs. */
+    /**
+     * Name of the synthetic input that holds synthesized externs.
+     */
   static final String SYNTHETIC_EXTERNS = "{SyntheticVarsDeclar}";
 
   private CompilerInput synthesizedExternsInput = null;
@@ -1949,12 +1774,7 @@
         default:
           throw new IllegalStateException("unexpected language mode");
       }
-
-      parserConfig = ParserRunner.createConfig(
-        isIdeMode(),
-        mode,
-        acceptConstKeyword(),
-        options.extraAnnotationNames);
+            parserConfig = ParserRunner.createConfig(isIdeMode(), mode, acceptConstKeyword(), options.extraAnnotationNames);
     }
     return parserConfig;
   }
@@ -1964,11 +1784,9 @@
     return options.checkTypes;
   }
 
-
   //------------------------------------------------------------------------
   // Error reporting
   //------------------------------------------------------------------------
-
   /**
    * The warning classes that are available from the command-line, and
    * are suppressable by the {@code @suppress} annotation.
@@ -1986,7 +1804,6 @@
         level = newLevel;
       }
     }
-
     if (level.isOn()) {
       if (getOptions().errorHandler != null) {
         getOptions().errorHandler.report(level, error);
@@ -2006,10 +1823,7 @@
    */
   @Override
   void throwInternalError(String message, Exception cause) {
-    String finalMessage =
-      "INTERNAL COMPILER ERROR.\n" +
-      "Please report this problem.\n" + message;
-
+        String finalMessage = "INTERNAL COMPILER ERROR.\n" + "Please report this problem.\n" + message;
     RuntimeException e = new RuntimeException(finalMessage, cause);
     if (cause != null) {
       e.setStackTrace(cause.getStackTrace());
@@ -2017,7 +1831,6 @@
     throw e;
   }
 
-
   /**
    * Gets the number of errors.
    */
@@ -2050,7 +1863,9 @@
     return hasHaltingErrors();
   }
 
-  /** Called from the compiler passes, adds debug info */
+    /**
+     * Called from the compiler passes, adds debug info
+     */
   @Override
   void addToDebugLog(String str) {
     debugLog.append(str);
@@ -2097,17 +1912,14 @@
   //------------------------------------------------------------------------
   // Package-private helpers
   //------------------------------------------------------------------------
-
   @Override
   Node getNodeForCodeInsertion(JSModule module) {
     if (module == null) {
       if (inputs.isEmpty()) {
         throw new IllegalStateException("No inputs");
       }
-
       return inputs.get(0).getAstRoot(this);
     }
-
     List<CompilerInput> moduleInputs = module.getInputs();
     if (moduleInputs.size() > 0) {
       return moduleInputs.get(0).getAstRoot(this);
@@ -2142,7 +1954,9 @@
     logger.setLevel(level);
   }
 
-  /** Gets the DOT graph of the AST generated at the end of compilation. */
+    /**
+     * Gets the DOT graph of the AST generated at the end of compilation.
+     */
   public String getAstDotGraph() throws IOException {
     if (jsRoot != null) {
       ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);
@@ -2192,19 +2006,29 @@
    * restoring intermediate state.
    */
   public static class IntermediateState implements Serializable {
+
     private static final long serialVersionUID = 1L;
 
     Node externsRoot;
+
     private Node jsRoot;
+
     private List<CompilerInput> externs;
+
     private List<CompilerInput> inputs;
+
     private List<JSModule> modules;
+
     private PassConfig.State passConfigState;
+
     private JSTypeRegistry typeRegistry;
+
     private AbstractCompiler.LifeCycleStage lifeCycleStage;
+
     private Map<String, Node> injectedLibraries;
 
-    private IntermediateState() {}
+        private IntermediateState() {
+        }
   }
 
   /**
@@ -2221,7 +2045,6 @@
     state.typeRegistry = typeRegistry;
     state.lifeCycleStage = getLifeCycleStage();
     state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);
-
     return state;
   }
 
@@ -2239,7 +2062,6 @@
     getPassConfig().setIntermediateState(state.passConfigState);
     typeRegistry = state.typeRegistry;
     setLifeCycleStage(state.lifeCycleStage);
-
     injectedLibraries.clear();
     injectedLibraries.putAll(state.injectedLibraries);
   }
@@ -2265,13 +2087,10 @@
   }
 
   @Override
-  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,
-      Node collectionRoot) {
-    Preconditions.checkState(collectionRoot.isScript()
-        || collectionRoot.isBlock());
+    void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) {
+        Preconditions.checkState(collectionRoot.isScript() || collectionRoot.isBlock());
     if (globalRefMap == null) {
-      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),
-          getExternsInOrder());
+            globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(), getExternsInOrder());
     }
     globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);
   }
@@ -2318,7 +2137,6 @@
       return;
     }
     Node originalRoot = input.getAstRoot(this);
-
     processNewScript(ast, originalRoot);
   }
 
@@ -2336,39 +2154,32 @@
     Node emptyScript = new Node(Token.SCRIPT);
     InputId inputId = ast.getInputId();
     emptyScript.setInputId(inputId);
-    emptyScript.setStaticSourceFile(
-        SourceFile.fromCode(inputId.getIdName(), ""));
-
+        emptyScript.setStaticSourceFile(SourceFile.fromCode(inputId.getIdName(), ""));
     processNewScript(ast, emptyScript);
   }
 
   private void processNewScript(JsAst ast, Node originalRoot) {
     Node js = ast.getAstRoot(this);
     Preconditions.checkNotNull(js);
-
     runHotSwap(originalRoot, js, this.getCleanupPassConfig());
     // NOTE: If hot swap passes that use GlobalNamespace are added, we will need
     // to revisit this approach to clearing GlobalNamespaces
     runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);
-
     this.getTypeRegistry().clearNamedTypes();
     this.removeSyntheticVarsInput();
-
     runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());
   }
 
   /**
    * Execute the passes from a PassConfig instance over a single replaced file.
    */
-  private void runHotSwap(
-      Node originalRoot, Node js, PassConfig passConfig) {
+    private void runHotSwap(Node originalRoot, Node js, PassConfig passConfig) {
     for (PassFactory passFactory : passConfig.getChecks()) {
       runHotSwapPass(originalRoot, js, passFactory);
     }
   }
 
-  private void runHotSwapPass(
-      Node originalRoot, Node js, PassFactory passFactory) {
+    private void runHotSwapPass(Node originalRoot, Node js, PassFactory passFactory) {
     HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);
     if (pass != null) {
       logger.info("Performing HotSwap for pass " + passFactory.getName());
@@ -2390,44 +2201,35 @@
     if (injectedLibraries.containsKey(resourceName)) {
       return null;
     }
-
     // All libraries depend on js/base.js
     boolean isBase = "base".equals(resourceName);
     if (!isBase) {
       ensureLibraryInjected("base");
     }
-
     Node firstChild = loadLibraryCode(resourceName).removeChildren();
     Node lastChild = firstChild.getLastSibling();
-
     Node parent = getNodeForCodeInsertion(null);
     if (isBase) {
       parent.addChildrenToFront(firstChild);
     } else {
-      parent.addChildrenAfter(
-          firstChild, injectedLibraries.get("base"));
+            parent.addChildrenAfter(firstChild, injectedLibraries.get("base"));
     }
     reportCodeChange();
-
     injectedLibraries.put(resourceName, lastChild);
     return lastChild;
   }
 
-  /** Load a library as a resource */
+    /**
+     * Load a library as a resource
+     */
   @VisibleForTesting
   Node loadLibraryCode(String resourceName) {
     String originalCode;
     try {
-      originalCode = CharStreams.toString(new InputStreamReader(
-          Compiler.class.getResourceAsStream(
-              String.format("js/%s.js", resourceName)),
-          Charsets.UTF_8));
+            originalCode = CharStreams.toString(new InputStreamReader(Compiler.class.getResourceAsStream(String.format("js/%s.js", resourceName)), Charsets.UTF_8));
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
-
-    return Normalize.parseAndNormalizeSyntheticCode(
-        this, originalCode,
-        String.format("jscomp_%s_", resourceName));
+        return Normalize.parseAndNormalizeSyntheticCode(this, originalCode, String.format("jscomp_%s_", resourceName));
   }
 }

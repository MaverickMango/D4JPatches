diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/jacksoncore/jacksoncore_8_buggy/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java /mnt/D4JPatches/Manual2023/patches_correct/JacksonCore/JacksonCore_8/JacksonCore_8_knod/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
--- /mnt/d4j_bug_info/buggyfiles/jacksoncore/jacksoncore_8_buggy/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java	2022-11-20 04:09:33.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_correct/JacksonCore/JacksonCore_8/JacksonCore_8_knod/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java	2023-11-13 22:37:06.000000000 -0800
@@ -3,7 +3,6 @@
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
-
 import com.fasterxml.jackson.core.io.NumberInput;
 
 /**
@@ -24,8 +23,8 @@
  *    </li>
  * </ul>
  */
-public final class TextBuffer
-{
+public final class TextBuffer {
+
     final static char[] NO_CHARS = new char[0];
 
     /**
@@ -44,7 +43,6 @@
     /* Configuration:
     /**********************************************************
      */
-
     private final BufferRecycler _allocator;
 
     /*
@@ -52,7 +50,6 @@
     /* Shared input buffers
     /**********************************************************
      */
-
     /**
      * Shared input buffer; stored here in case some input can be returned
      * as is, without being copied to collector's own buffers. Note that
@@ -73,7 +70,6 @@
     /* Aggregation segments (when not using input buf)
     /**********************************************************
      */
-
     /**
      * List of segments prior to currently active segment.
      */
@@ -85,7 +81,6 @@
     private boolean _hasSegments = false;
 
     // // // Currently used segment; not (yet) contained in _seqments
-
     /**
      * Amount of characters in segments in {@link _segments}
      */
@@ -103,7 +98,6 @@
     /* Caching of results
     /**********************************************************
      */
-
     /**
      * String that will be constructed when the whole contents are
      * needed; will be temporarily stored in case asked for again.
@@ -117,7 +111,6 @@
     /* Life-cycle
     /**********************************************************
      */
-
     public TextBuffer(BufferRecycler allocator) {
         _allocator = allocator;
     }
@@ -131,8 +124,7 @@
      * Note: calling this method automatically also clears contents
      * of the buffer.
      */
-    public void releaseBuffers()
-    {
+    public void releaseBuffers() {
         if (_allocator == null) {
             resetWithEmpty();
         } else {
@@ -151,16 +143,14 @@
      * Method called to clear out any content text buffer may have, and
      * initializes buffer to use non-shared data.
      */
-    public void resetWithEmpty()
-    {
-        _inputStart = -1; // indicates shared buffer not used
+    public void resetWithEmpty() {
+        // indicates shared buffer not used
+        _inputStart = -1;
         _currentSize = 0;
         _inputLen = 0;
-
         _inputBuffer = null;
         _resultString = null;
         _resultArray = null;
-
         // And then reset internal input buffers, if necessary:
         if (_hasSegments) {
             clearSegments();
@@ -173,32 +163,27 @@
      * also means that if anything is to be appended to the buffer, it
      * will first have to unshare it (make a local copy).
      */
-    public void resetWithShared(char[] buf, int start, int len)
-    {
+    public void resetWithShared(char[] buf, int start, int len) {
         // First, let's clear intermediate values, if any:
         _resultString = null;
         _resultArray = null;
-
         // Then let's mark things we need about input buffer
         _inputBuffer = buf;
         _inputStart = start;
         _inputLen = len;
-
         // And then reset internal input buffers, if necessary:
         if (_hasSegments) {
             clearSegments();
         }
     }
 
-    public void resetWithCopy(char[] buf, int start, int len)
-    {
+    public void resetWithCopy(char[] buf, int start, int len) {
         _inputBuffer = null;
-        _inputStart = -1; // indicates shared buffer not used
+        // indicates shared buffer not used
+        _inputStart = -1;
         _inputLen = 0;
-
         _resultString = null;
         _resultArray = null;
-
         // And then reset internal input buffers, if necessary:
         if (_hasSegments) {
             clearSegments();
@@ -209,36 +194,30 @@
         append(buf, start, len);
     }
 
-    public void resetWithString(String value)
-    {
+    public void resetWithString(String value) {
         _inputBuffer = null;
         _inputStart = -1;
         _inputLen = 0;
-
         _resultString = value;
         _resultArray = null;
-
         if (_hasSegments) {
             clearSegments();
         }
         _currentSize = 0;
-        
     }
     
     /**
      * Helper method used to find a buffer to use, ideally one
      * recycled earlier.
      */
-    private char[] buf(int needed)
-    {
+    private char[] buf(int needed) {
         if (_allocator != null) {
             return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);
         }
         return new char[Math.max(needed, MIN_SEGMENT_LEN)];
     }
 
-    private void clearSegments()
-    {
+    private void clearSegments() {
         _hasSegments = false;
         /* Let's start using _last_ segment from list; for one, it's
          * the biggest one, and it's also most likely to be cached
@@ -256,12 +235,12 @@
     /* Accessors for implementing public interface
     /**********************************************************
      */
-
     /**
      * @return Number of characters currently stored by this collector
      */
     public int size() {
-        if (_inputStart >= 0) { // shared copy from input buf
+        if (_inputStart >= 0) {
+            // shared copy from input buf
             return _inputLen;
         }
         if (_resultArray != null) {
@@ -286,25 +265,29 @@
      * Method that can be used to check whether textual contents can
      * be efficiently accessed using {@link #getTextBuffer}.
      */
-    public boolean hasTextAsCharacters()
-    {
+    public boolean hasTextAsCharacters() {
         // if we have array in some form, sure
-        if (_inputStart >= 0 || _resultArray != null)  return true;
+        if (_inputStart >= 0 || _resultArray != null)
+            return true;
         // not if we have String as value
-        if (_resultString != null) return false;
+        if (_resultString != null)
+            return false;
         return true;
     }
     
-    public char[] getTextBuffer()
-    {
+    public char[] getTextBuffer() {
         // Are we just using shared input buffer?
-        if (_inputStart >= 0) return _inputBuffer;
-        if (_resultArray != null)  return _resultArray;
+        if (_inputStart >= 0)
+            return _inputBuffer;
+        if (_resultArray != null)
+            return _resultArray;
         if (_resultString != null) {
             return (_resultArray = _resultString.toCharArray());
         }
         // Nope; but does it fit in just one segment?
-        if (!_hasSegments)  return _currentSegment;
+        if (_resultString != null) {
+            return _currentSegment;
+        }
         // Nope, need to have/create a non-segmented array and return it
         return contentsAsArray();
     }
@@ -314,9 +297,7 @@
     /* Other accessors:
     /**********************************************************
      */
-
-    public String contentsAsString()
-    {
+    public String contentsAsString() {
         if (_resultString == null) {
             // Has array been requested? Can make a shortcut, if so:
             if (_resultArray != null) {
@@ -328,14 +309,16 @@
                         return (_resultString = "");
                     }
                     _resultString = new String(_inputBuffer, _inputStart, _inputLen);
-                } else { // nope... need to copy
+                } else {
+                    // nope... need to copy
                     // But first, let's see if we have just one buffer
                     int segLen = _segmentSize;
                     int currLen = _currentSize;
-                    
-                    if (segLen == 0) { // yup
+                    if (segLen == 0) {
+                        // yup
                         _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen);
-                    } else { // no, need to combine
+                    } else {
+                        // no, need to combine
                         StringBuilder sb = new StringBuilder(segLen + currLen);
                         // First stored segments
                         if (_segments != null) {
@@ -366,8 +349,7 @@
      * Convenience method for converting contents of the buffer
      * into a {@link BigDecimal}.
      */
-    public BigDecimal contentsAsDecimal() throws NumberFormatException
-    {
+    public BigDecimal contentsAsDecimal() throws NumberFormatException {
         // Already got a pre-cut array?
         if (_resultArray != null) {
             return NumberInput.parseBigDecimal(_resultArray);
@@ -397,7 +379,6 @@
     /* Public mutators:
     /**********************************************************
      */
-
     /**
      * Method called to make sure that buffer is not using shared input
      * buffer; if it is, it will copy such contents to private buffer.
@@ -424,19 +405,16 @@
         curr[_currentSize++] = c;
     }
 
-    public void append(char[] c, int start, int len)
-    {
+    public void append(char[] c, int start, int len) {
         // Can't append to shared buf (sanity check)
         if (_inputStart >= 0) {
             unshare(len);
         }
         _resultString = null;
         _resultArray = null;
-
         // Room in current segment?
         char[] curr = _currentSegment;
         int max = curr.length - _currentSize;
-            
         if (max >= len) {
             System.arraycopy(c, start, curr, _currentSize, len);
             _currentSize += len;
@@ -462,15 +440,13 @@
         } while (len > 0);
     }
 
-    public void append(String str, int offset, int len)
-    {
+    public void append(String str, int offset, int len) {
         // Can't append to shared buf (sanity check)
         if (_inputStart >= 0) {
             unshare(len);
         }
         _resultString = null;
         _resultArray = null;
-
         // Room in current segment?
         char[] curr = _currentSegment;
         int max = curr.length - _currentSize;
@@ -504,9 +480,7 @@
     /* Raw access, for high-performance use:
     /**********************************************************
      */
-
-    public char[] getCurrentSegment()
-    {
+    public char[] getCurrentSegment() {
         /* Since the intention of the caller is to directly add stuff into
          * buffers, we should NOT have anything in shared buffer... ie. may
          * need to unshare contents.
@@ -525,17 +499,15 @@
         return _currentSegment;
     }
 
-    public char[] emptyAndGetCurrentSegment()
-    {
+    public char[] emptyAndGetCurrentSegment() {
         // inlined 'resetWithEmpty()'
-        _inputStart = -1; // indicates shared buffer not used
+        // indicates shared buffer not used
+        _inputStart = -1;
         _currentSize = 0;
         _inputLen = 0;
-
         _inputBuffer = null;
         _resultString = null;
         _resultArray = null;
-
         // And then reset internal input buffers, if necessary:
         if (_hasSegments) {
             clearSegments();
@@ -547,8 +519,13 @@
         return curr;
     }
 
-    public int getCurrentSegmentSize() { return _currentSize; }
-    public void setCurrentLength(int len) { _currentSize = len; }
+    public int getCurrentSegmentSize() {
+        return _currentSize;
+    }
+
+    public void setCurrentLength(int len) {
+        _currentSize = len;
+    }
 
     /**
      * @since 2.6
@@ -556,7 +533,8 @@
     public String setCurrentAndReturn(int len) {
         _currentSize = len;
         // We can simplify handling here compared to full `contentsAsString()`:
-        if (_segmentSize > 0) { // longer text; call main method
+        if (_segmentSize > 0) {
+            // longer text; call main method
             return contentsAsString();
         }
         // more common case: single segment
@@ -575,7 +553,6 @@
         int oldLen = _currentSegment.length;
         _segmentSize += oldLen;
         _currentSize = 0;
-
         // Let's grow segments by 50%
         int newLen = oldLen + (oldLen >> 1);
         if (newLen < MIN_SEGMENT_LEN) {
@@ -593,8 +570,7 @@
      * accommodate for more contiguous content. Usually only
      * used when parsing tokens like names if even then.
      */
-    public char[] expandCurrentSegment()
-    {
+    public char[] expandCurrentSegment() {
         final char[] curr = _currentSegment;
         // Let's grow by 50% by default
         final int len = curr.length;
@@ -617,7 +593,8 @@
      */
     public char[] expandCurrentSegment(int minSize) {
         char[] curr = _currentSegment;
-        if (curr.length >= minSize) return curr;
+        if (curr.length >= minSize)
+            return curr;
         _currentSegment = curr = Arrays.copyOf(curr, minSize);
         return curr;
     }
@@ -627,33 +604,32 @@
     /* Standard methods:
     /**********************************************************
      */
-
     /**
      * Note: calling this method may not be as efficient as calling
      * {@link #contentsAsString}, since it's not guaranteed that resulting
      * String is cached.
      */
-    @Override public String toString() { return contentsAsString(); }
+    @Override
+    public String toString() {
+        return contentsAsString();
+    }
 
     /*
     /**********************************************************
     /* Internal methods:
     /**********************************************************
      */
-
     /**
      * Method called if/when we need to append content when we have been
      * initialized to use shared buffer.
      */
-    private void unshare(int needExtra)
-    {
+    private void unshare(int needExtra) {
         int sharedLen = _inputLen;
         _inputLen = 0;
         char[] inputBuf = _inputBuffer;
         _inputBuffer = null;
         int start = _inputStart;
         _inputStart = -1;
-
         // Is buffer big enough, or do we need to reallocate?
         int needed = sharedLen+needExtra;
         if (_currentSegment == null || needed > _currentSegment.length) {
@@ -670,8 +646,7 @@
      * Method called when current segment is full, to allocate new
      * segment.
      */
-    private void expand(int minNewSegmentSize)
-    {
+    private void expand(int minNewSegmentSize) {
         // First, let's move current segment to segment list:
         if (_segments == null) {
             _segments = new ArrayList<char[]>();
@@ -682,7 +657,6 @@
         _segmentSize += curr.length;
         _currentSize = 0;
         int oldLen = curr.length;
-        
         // Let's grow segments by 50% minimum
         int newLen = oldLen + (oldLen >> 1);
         if (newLen < MIN_SEGMENT_LEN) {
@@ -693,9 +667,9 @@
         _currentSegment = carr(newLen);
     }
 
-    private char[] resultArray()
-    {
-        if (_resultString != null) { // Can take a shortcut...
+    private char[] resultArray() {
+        if (_resultString != null) {
+            // Can take a shortcut...
             return _resultString.toCharArray();
         }
         // Do we use shared array?
@@ -729,5 +703,7 @@
         return result;
     }
 
-    private char[] carr(int len) { return new char[len]; }
+    private char[] carr(int len) {
+        return new char[len];
+    }
 }

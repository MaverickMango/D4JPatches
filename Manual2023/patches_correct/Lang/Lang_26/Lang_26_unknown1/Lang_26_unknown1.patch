diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/lang/lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java /mnt/D4JPatches/Manual2023/patches_correct/Lang/Lang_26/Lang_26_unknown1/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java
--- /mnt/d4j_bug_info/buggyfiles/lang/lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java	2022-11-20 04:09:31.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_correct/Lang/Lang_26/Lang_26_unknown1/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java	2023-11-13 22:37:06.000000000 -0800
@@ -33,7 +33,6 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
-
 import org.apache.commons.lang3.Validate;
 
 /**
@@ -69,6 +68,7 @@
  * @version $Id$
  */
 public class FastDateFormat extends Format {
+
     // A lot of the speed in this class comes from caching, but some comes
     // from the special int to StringBuffer conversion.
     //
@@ -80,7 +80,6 @@
     // Note that Integer.toString() is not called, the conversion is simply
     // taking the value and adding (mathematically) the ASCII value for '0'.
     // So, don't change this code! It works and is very fast.
-    
     /**
      * Required for serialization support.
      * 
@@ -92,52 +91,66 @@
      * FULL locale dependent date or time style.
      */
     public static final int FULL = DateFormat.FULL;
+
     /**
      * LONG locale dependent date or time style.
      */
     public static final int LONG = DateFormat.LONG;
+
     /**
      * MEDIUM locale dependent date or time style.
      */
     public static final int MEDIUM = DateFormat.MEDIUM;
+
     /**
      * SHORT locale dependent date or time style.
      */
     public static final int SHORT = DateFormat.SHORT;
     
     //@GuardedBy("this")
-    private static String cDefaultPattern; // lazily initialised by getInstance()
+    // lazily initialised by getInstance()
+    private static String cDefaultPattern;
 
     private static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7);
+
     private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);
+
     private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);
+
     private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);
+
     private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);
 
     /**
      * The pattern.
      */
     private final String mPattern;
+
     /**
      * The time zone.
      */
     private final TimeZone mTimeZone;
+
     /**
      * Whether the time zone overrides any on Calendars.
      */
     private final boolean mTimeZoneForced;
+
     /**
      * The locale.
      */
     private final Locale mLocale;
+
     /**
      * Whether the locale overrides the default.
      */
     private final boolean mLocaleForced;
+
     /**
      * The parsed rules.
      */
     private transient Rule[] mRules;
+
     /**
      * The estimated maximum length.
      */
@@ -214,8 +227,10 @@
         FastDateFormat format = cInstanceCache.get(emptyFormat);
         if (format == null) {
             format = emptyFormat;
-            format.init();  // convert shell format into usable one
-            cInstanceCache.put(format, format);  // this is OK!
+            // convert shell format into usable one
+            format.init();
+            // this is OK!
+            cInstanceCache.put(format, format);
         }
         return format;
     }
@@ -265,6 +280,7 @@
     public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
         return getDateInstance(style, timeZone, null);
     }
+
     /**
      * <p>Gets a date formatter instance using the specified style, time
      * zone and locale.</p>
@@ -282,13 +298,10 @@
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
-
         if (locale == null) {
             locale = Locale.getDefault();
         }
-
         key = new Pair(key, locale);
-
         FastDateFormat format = cDateInstanceCache.get(key);
         if (format == null) {
             try {
@@ -296,7 +309,6 @@
                 String pattern = formatter.toPattern();
                 format = getInstance(pattern, timeZone, locale);
                 cDateInstanceCache.put(key, format);
-                
             } catch (ClassCastException ex) {
                 throw new IllegalArgumentException("No date pattern for locale: " + locale);
             }
@@ -370,19 +382,16 @@
         if (locale != null) {
             key = new Pair(key, locale);
         }
-
         FastDateFormat format = cTimeInstanceCache.get(key);
         if (format == null) {
             if (locale == null) {
                 locale = Locale.getDefault();
             }
-
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
                 String pattern = formatter.toPattern();
                 format = getInstance(pattern, timeZone, locale);
                 cTimeInstanceCache.put(key, format);
-            
             } catch (ClassCastException ex) {
                 throw new IllegalArgumentException("No date pattern for locale: " + locale);
             }
@@ -402,8 +411,7 @@
      *  pattern defined
      * @since 2.1
      */
-    public static FastDateFormat getDateTimeInstance(
-            int dateStyle, int timeStyle) {
+    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
         return getDateTimeInstance(dateStyle, timeStyle, null, null);
     }
     
@@ -419,8 +427,7 @@
      *  pattern defined
      * @since 2.1
      */
-    public static FastDateFormat getDateTimeInstance(
-            int dateStyle, int timeStyle, Locale locale) {
+    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
         return getDateTimeInstance(dateStyle, timeStyle, null, locale);
     }
     
@@ -437,10 +444,10 @@
      *  pattern defined
      * @since 2.1
      */
-    public static FastDateFormat getDateTimeInstance(
-            int dateStyle, int timeStyle, TimeZone timeZone) {
+    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
         return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
     }    
+
     /**
      * <p>Gets a date/time formatter instance using the specified style,
      * time zone and locale.</p>
@@ -454,9 +461,7 @@
      * @throws IllegalArgumentException if the Locale has no date/time
      *  pattern defined
      */
-    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,
-            Locale locale) {
-
+    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
         Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));
         if (timeZone != null) {
             key = new Pair(key, timeZone);
@@ -465,16 +470,13 @@
             locale = Locale.getDefault();
         }
         key = new Pair(key, locale);
-
         FastDateFormat format = cDateTimeInstanceCache.get(key);
         if (format == null) {
             try {
-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
-                        locale);
+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
                 String pattern = formatter.toPattern();
                 format = getInstance(pattern, timeZone, locale);
                 cDateTimeInstanceCache.put(key, format);
-
             } catch (ClassCastException ex) {
                 throw new IllegalArgumentException("No date time pattern for locale: " + locale);
             }
@@ -537,13 +539,11 @@
             throw new IllegalArgumentException("The pattern must not be null");
         }
         mPattern = pattern;
-        
         mTimeZoneForced = (timeZone != null);
         if (timeZone == null) {
             timeZone = TimeZone.getDefault();
         }
         mTimeZone = timeZone;
-        
         mLocaleForced = (locale != null);
         if (locale == null) {
             locale = Locale.getDefault();
@@ -557,12 +557,10 @@
     protected void init() {
         List<Rule> rulesList = parsePattern();
         mRules = rulesList.toArray(new Rule[rulesList.size()]);
-
         int len = 0;
         for (int i=mRules.length; --i >= 0; ) {
             len += mRules[i].estimateLength();
         }
-
         mMaxLengthEstimate = len;
     }
 
@@ -577,42 +575,39 @@
     protected List<Rule> parsePattern() {
         DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
         List<Rule> rules = new ArrayList<Rule>();
-
         String[] ERAs = symbols.getEras();
         String[] months = symbols.getMonths();
         String[] shortMonths = symbols.getShortMonths();
         String[] weekdays = symbols.getWeekdays();
         String[] shortWeekdays = symbols.getShortWeekdays();
         String[] AmPmStrings = symbols.getAmPmStrings();
-
         int length = mPattern.length();
         int[] indexRef = new int[1];
-
         for (int i = 0; i < length; i++) {
             indexRef[0] = i;
             String token = parseToken(mPattern, indexRef);
             i = indexRef[0];
-
             int tokenLen = token.length();
             if (tokenLen == 0) {
                 break;
             }
-
             Rule rule;
             char c = token.charAt(0);
-
             switch (c) {
-            case 'G': // era designator (text)
+                case // era designator (text)
+                'G':
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
-            case 'y': // year (number)
+                case // year (number)
+                'y':
                 if (tokenLen >= 4) {
                     rule = selectNumberRule(Calendar.YEAR, tokenLen);
                 } else {
                     rule = TwoDigitYearField.INSTANCE;
                 }
                 break;
-            case 'M': // month in year (text and number)
+                case // month in year (text and number)
+                'M':
                 if (tokenLen >= 4) {
                     rule = new TextField(Calendar.MONTH, months);
                 } else if (tokenLen == 3) {
@@ -623,63 +618,80 @@
                     rule = UnpaddedMonthField.INSTANCE;
                 }
                 break;
-            case 'd': // day in month (number)
+                case // day in month (number)
+                'd':
                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
                 break;
-            case 'h': // hour in am/pm (number, 1..12)
+                case // hour in am/pm (number, 1..12)
+                'h':
                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
                 break;
-            case 'H': // hour in day (number, 0..23)
+                case // hour in day (number, 0..23)
+                'H':
                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
                 break;
-            case 'm': // minute in hour (number)
+                case // minute in hour (number)
+                'm':
                 rule = selectNumberRule(Calendar.MINUTE, tokenLen);
                 break;
-            case 's': // second in minute (number)
+                case // second in minute (number)
+                's':
                 rule = selectNumberRule(Calendar.SECOND, tokenLen);
                 break;
-            case 'S': // millisecond (number)
+                case // millisecond (number)
+                'S':
                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
                 break;
-            case 'E': // day in week (text)
+                case // day in week (text)
+                'E':
                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                 break;
-            case 'D': // day in year (number)
+                case // day in year (number)
+                'D':
                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                 break;
-            case 'F': // day of week in month (number)
+                case // day of week in month (number)
+                'F':
                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
                 break;
-            case 'w': // week in year (number)
+                case // week in year (number)
+                'w':
                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
                 break;
-            case 'W': // week in month (number)
+                case // week in month (number)
+                'W':
                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
                 break;
-            case 'a': // am/pm marker (text)
+                case // am/pm marker (text)
+                'a':
                 rule = new TextField(Calendar.AM_PM, AmPmStrings);
                 break;
-            case 'k': // hour in day (1..24)
+                case // hour in day (1..24)
+                'k':
                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
                 break;
-            case 'K': // hour in am/pm (0..11)
+                case // hour in am/pm (0..11)
+                'K':
                 rule = selectNumberRule(Calendar.HOUR, tokenLen);
                 break;
-            case 'z': // time zone (text)
+                case // time zone (text)
+                'z':
                 if (tokenLen >= 4) {
                     rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
                 } else {
                     rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
                 }
                 break;
-            case 'Z': // time zone (value)
+                case // time zone (value)
+                'Z':
                 if (tokenLen == 1) {
                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
                 } else {
                     rule = TimeZoneNumberRule.INSTANCE_COLON;
                 }
                 break;
-            case '\'': // literal text
+                case // literal text
+                '\'':
                 String sub = token.substring(1);
                 if (sub.length() == 1) {
                     rule = new CharacterLiteral(sub.charAt(0));
@@ -690,10 +702,8 @@
             default:
                 throw new IllegalArgumentException("Illegal pattern component: " + token);
             }
-
             rules.add(rule);
         }
-
         return rules;
     }
 
@@ -706,16 +716,13 @@
      */
     protected String parseToken(String pattern, int[] indexRef) {
         StringBuilder buf = new StringBuilder();
-
         int i = indexRef[0];
         int length = pattern.length();
-
         char c = pattern.charAt(i);
         if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
             // Scan a run of the same character, which indicates a time
             // pattern.
             buf.append(c);
-
             while (i + 1 < length) {
                 char peek = pattern.charAt(i + 1);
                 if (peek == c) {
@@ -728,12 +735,9 @@
         } else {
             // This will identify token as text.
             buf.append('\'');
-
             boolean inLiteral = false;
-
             for (; i < length; i++) {
                 c = pattern.charAt(i);
-
                 if (c == '\'') {
                     if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                         // '' is treated as escaped '
@@ -742,8 +746,7 @@
                     } else {
                         inLiteral = !inLiteral;
                     }
-                } else if (!inLiteral &&
-                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
+                } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                     i--;
                     break;
                 } else {
@@ -751,7 +754,6 @@
                 }
             }
         }
-
         indexRef[0] = i;
         return buf.toString();
     }
@@ -794,8 +796,7 @@
         } else if (obj instanceof Long) {
             return format(((Long) obj).longValue(), toAppendTo);
         } else {
-            throw new IllegalArgumentException("Unknown class: " +
-                (obj == null ? "<null>" : obj.getClass().getName()));
+            throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName()));
         }
     }
 
@@ -817,7 +818,7 @@
      * @return the formatted string
      */
     public String format(Date date) {
-        Calendar c = new GregorianCalendar(mTimeZone);
+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
@@ -869,7 +870,8 @@
      */
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
-            calendar.getTimeInMillis(); /// LANG-538
+            /// LANG-538
+            calendar.getTimeInMillis();
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
@@ -981,13 +983,7 @@
             return false;
         }
         FastDateFormat other = (FastDateFormat) obj;
-        if (
-            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&
-            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&
-            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&
-            (mTimeZoneForced == other.mTimeZoneForced) &&
-            (mLocaleForced == other.mLocaleForced)
-            ) {
+        if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
             return true;
         }
         return false;
@@ -1040,6 +1036,7 @@
      * <p>Inner class defining a rule.</p>
      */
     private interface Rule {
+
         /**
          * Returns the estimated lentgh of the result.
          * 
@@ -1060,6 +1057,7 @@
      * <p>Inner class defining a numeric rule.</p>
      */
     private interface NumberRule extends Rule {
+
         /**
          * Appends the specified value to the output buffer based on the rule implementation.
          * 
@@ -1073,6 +1071,7 @@
      * <p>Inner class to output a constant single character.</p>
      */
     private static class CharacterLiteral implements Rule {
+
         private final char mValue;
 
         /**
@@ -1104,6 +1103,7 @@
      * <p>Inner class to output a constant string.</p>
      */
     private static class StringLiteral implements Rule {
+
         private final String mValue;
 
         /**
@@ -1135,7 +1135,9 @@
      * <p>Inner class to output one of a set of values.</p>
      */
     private static class TextField implements Rule {
+
         private final int mField;
+
         private final String[] mValues;
 
         /**
@@ -1176,6 +1178,7 @@
      * <p>Inner class to output an unpadded number.</p>
      */
     private static class UnpaddedNumberField implements NumberRule {
+
         private final int mField;
 
         /**
@@ -1220,11 +1223,11 @@
      * <p>Inner class to output an unpadded month.</p>
      */
     private static class UnpaddedMonthField implements NumberRule {
+
         static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();
 
         /**
          * Constructs an instance of <code>UnpaddedMonthField</code>.
-         *
          */
         UnpaddedMonthField() {
             super();
@@ -1261,7 +1264,9 @@
      * <p>Inner class to output a padded number.</p>
      */
     private static class PaddedNumberField implements NumberRule {
+
         private final int mField;
+
         private final int mSize;
 
         /**
@@ -1323,6 +1328,7 @@
      * <p>Inner class to output a two digit number.</p>
      */
     private static class TwoDigitNumberField implements NumberRule {
+
         private final int mField;
 
         /**
@@ -1365,6 +1371,7 @@
      * <p>Inner class to output a two digit year.</p>
      */
     private static class TwoDigitYearField implements NumberRule {
+
         static final TwoDigitYearField INSTANCE = new TwoDigitYearField();
 
         /**
@@ -1401,6 +1408,7 @@
      * <p>Inner class to output a two digit month.</p>
      */
     private static class TwoDigitMonthField implements NumberRule {
+
         static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();
 
         /**
@@ -1437,6 +1445,7 @@
      * <p>Inner class to output the twelve hour field.</p>
      */
     private static class TwelveHourField implements NumberRule {
+
         private final NumberRule mRule;
 
         /**
@@ -1479,6 +1488,7 @@
      * <p>Inner class to output the twenty four hour field.</p>
      */
     private static class TwentyFourHourField implements NumberRule {
+
         private final NumberRule mRule;
 
         /**
@@ -1521,11 +1531,17 @@
      * <p>Inner class to output a time zone name.</p>
      */
     private static class TimeZoneNameRule implements Rule {
+
         private final TimeZone mTimeZone;
+
         private final boolean mTimeZoneForced;
+
         private final Locale mLocale;
+
         private final int mStyle;
+
         private final String mStandard;
+
         private final String mDaylight;
 
         /**
@@ -1541,7 +1557,6 @@
             mTimeZoneForced = timeZoneForced;
             mLocale = locale;
             mStyle = style;
-
             if (timeZoneForced) {
                 mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
                 mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
@@ -1590,7 +1605,9 @@
      * or <code>+/-HH:MM</code>.</p>
      */
     private static class TimeZoneNumberRule implements Rule {
+
         static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);
+
         static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);
         
         final boolean mColon;
@@ -1616,22 +1633,18 @@
          */
         public void appendTo(StringBuffer buffer, Calendar calendar) {
             int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
-            
             if (offset < 0) {
                 buffer.append('-');
                 offset = -offset;
             } else {
                 buffer.append('+');
             }
-            
             int hours = offset / (60 * 60 * 1000);
             buffer.append((char)(hours / 10 + '0'));
             buffer.append((char)(hours % 10 + '0'));
-            
             if (mColon) {
                 buffer.append(':');
             }
-            
             int minutes = offset / (60 * 1000) - 60 * hours;
             buffer.append((char)(minutes / 10 + '0'));
             buffer.append((char)(minutes % 10 + '0'));
@@ -1643,8 +1656,11 @@
      * <p>Inner class that acts as a compound key for time zone names.</p>
      */
     private static class TimeZoneDisplayKey {
+
         private final TimeZone mTimeZone;
+
         private final int mStyle;
+
         private final Locale mLocale;
 
         /**
@@ -1655,8 +1671,7 @@
          * @param style the timezone style
          * @param locale the timezone locale
          */
-        TimeZoneDisplayKey(TimeZone timeZone,
-                           boolean daylight, int style, Locale locale) {
+        TimeZoneDisplayKey(TimeZone timeZone, boolean daylight, int style, Locale locale) {
             mTimeZone = timeZone;
             if (daylight) {
                 style |= 0x80000000;
@@ -1683,10 +1698,7 @@
             }
             if (obj instanceof TimeZoneDisplayKey) {
                 TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;
-                return
-                    mTimeZone.equals(other.mTimeZone) &&
-                    mStyle == other.mStyle &&
-                    mLocale.equals(other.mLocale);
+                return mTimeZone.equals(other.mTimeZone) && mStyle == other.mStyle && mLocale.equals(other.mLocale);
             }
             return false;
         }
@@ -1700,7 +1712,9 @@
      * out of multiple objects.</p>
      */
     private static class Pair {
+
         private final Object mObj1;
+
         private final Object mObj2;
 
         /**
@@ -1721,18 +1735,11 @@
             if (this == obj) {
                 return true;
             }
-
             if (!(obj instanceof Pair)) {
                 return false;
             }
-
             Pair key = (Pair)obj;
-
-            return
-                (mObj1 == null ?
-                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&
-                (mObj2 == null ?
-                 key.mObj2 == null : mObj2.equals(key.mObj2));
+            return (mObj1 == null ? key.mObj1 == null : mObj1.equals(key.mObj1)) && (mObj2 == null ? key.mObj2 == null : mObj2.equals(key.mObj2));
         }
 
         /**
@@ -1740,9 +1747,7 @@
          */
         @Override
         public int hashCode() {
-            return
-                (mObj1 == null ? 0 : mObj1.hashCode()) +
-                (mObj2 == null ? 0 : mObj2.hashCode());
+            return (mObj1 == null ? 0 : mObj1.hashCode()) + (mObj2 == null ? 0 : mObj2.hashCode());
         }
 
         /**
@@ -1753,5 +1758,4 @@
             return "[" + mObj1 + ':' + mObj2 + ']';
         }
     }
-
 }

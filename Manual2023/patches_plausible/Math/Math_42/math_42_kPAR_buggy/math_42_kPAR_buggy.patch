diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/math/math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java /mnt/D4JPatches/Manual2023/patches_plausible/Math/Math_42/math_42_kPAR_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
--- /mnt/d4j_bug_info/buggyfiles/math/math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java	2022-11-20 04:09:32.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_plausible/Math/Math_42/math_42_kPAR_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java	2023-11-13 22:37:06.000000000 -0800
@@ -14,7 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.commons.math.optimization.linear;
 
 import java.io.IOException;
@@ -26,7 +25,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-
 import org.apache.commons.math.linear.Array2DRowRealMatrix;
 import org.apache.commons.math.linear.MatrixUtils;
 import org.apache.commons.math.linear.RealMatrix;
@@ -62,43 +60,69 @@
  */
 class SimplexTableau implements Serializable {
 
-    /** Column label for negative vars. */
+    /**
+     * Column label for negative vars.
+     */
     private static final String NEGATIVE_VAR_COLUMN_LABEL = "x-";
 
-    /** Default amount of error to accept in floating point comparisons (as ulps). */
+    /**
+     * Default amount of error to accept in floating point comparisons (as ulps).
+     */
     private static final int DEFAULT_ULPS = 10;
 
-    /** Serializable version identifier. */
+    /**
+     * Serializable version identifier.
+     */
     private static final long serialVersionUID = -1369660067587938365L;
 
-    /** Linear objective function. */
+    /**
+     * Linear objective function.
+     */
     private final LinearObjectiveFunction f;
 
-    /** Linear constraints. */
+    /**
+     * Linear constraints.
+     */
     private final List<LinearConstraint> constraints;
 
-    /** Whether to restrict the variables to non-negative values. */
+    /**
+     * Whether to restrict the variables to non-negative values.
+     */
     private final boolean restrictToNonNegative;
 
-    /** The variables each column represents */
+    /**
+     * The variables each column represents
+     */
     private final List<String> columnLabels = new ArrayList<String>();
 
-    /** Simple tableau. */
+    /**
+     * Simple tableau.
+     */
     private transient RealMatrix tableau;
 
-    /** Number of decision variables. */
+    /**
+     * Number of decision variables.
+     */
     private final int numDecisionVariables;
 
-    /** Number of slack variables. */
+    /**
+     * Number of slack variables.
+     */
     private final int numSlackVariables;
 
-    /** Number of artificial variables. */
+    /**
+     * Number of artificial variables.
+     */
     private int numArtificialVariables;
 
-    /** Amount of error to accept when checking for optimality. */
+    /**
+     * Amount of error to accept when checking for optimality.
+     */
     private final double epsilon;
 
-    /** Amount of error to accept in floating point comparisons. */
+    /**
+     * Amount of error to accept in floating point comparisons.
+     */
     private final int maxUlps;
 
     /**
@@ -110,10 +134,7 @@
      * @param restrictToNonNegative whether to restrict the variables to non-negative values
      * @param epsilon amount of error to accept when checking for optimality
      */
-    SimplexTableau(final LinearObjectiveFunction f,
-                   final Collection<LinearConstraint> constraints,
-                   final GoalType goalType, final boolean restrictToNonNegative,
-                   final double epsilon) {
+    SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
         this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);
     }
 
@@ -127,22 +148,15 @@
      * @param epsilon amount of error to accept when checking for optimality
      * @param maxUlps amount of error to accept in floating point comparisons
      */
-    SimplexTableau(final LinearObjectiveFunction f,
-                   final Collection<LinearConstraint> constraints,
-                   final GoalType goalType, final boolean restrictToNonNegative,
-                   final double epsilon,
-                   final int maxUlps) {
+    SimplexTableau(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative, final double epsilon, final int maxUlps) {
         this.f                      = f;
         this.constraints            = normalizeConstraints(constraints);
         this.restrictToNonNegative  = restrictToNonNegative;
         this.epsilon                = epsilon;
         this.maxUlps                = maxUlps;
-        this.numDecisionVariables   = f.getCoefficients().getDimension() +
-                                      (restrictToNonNegative ? 0 : 1);
-        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +
-                                      getConstraintTypeCounts(Relationship.GEQ);
-        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +
-                                      getConstraintTypeCounts(Relationship.GEQ);
+        this.numDecisionVariables = f.getCoefficients().getDimension() + (restrictToNonNegative ? 0 : 1);
+        this.numSlackVariables = getConstraintTypeCounts(Relationship.LEQ) + getConstraintTypeCounts(Relationship.GEQ);
+        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) + getConstraintTypeCounts(Relationship.GEQ);
         this.tableau = createTableau(goalType == GoalType.MAXIMIZE);
         initializeColumnLabels();
     }
@@ -176,65 +190,52 @@
      * @return created tableau
      */
     protected RealMatrix createTableau(final boolean maximize) {
-
         // create a matrix of the correct size
-        int width = numDecisionVariables + numSlackVariables +
-        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
+        int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + // + 1 is for RHS
+        1;
         int height = constraints.size() + getNumObjectiveFunctions();
         Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);
-
         // initialize the objective function rows
         if (getNumObjectiveFunctions() == 2) {
             matrix.setEntry(0, 0, -1);
         }
         int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
         matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
-        RealVector objectiveCoefficients =
-            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
+        RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
         copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);
-        matrix.setEntry(zIndex, width - 1,
-            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());
-
+        matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.hashCode());
         if (!restrictToNonNegative) {
-            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
-                getInvertedCoefficientSum(objectiveCoefficients));
+            matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients));
         }
-
         // initialize the constraint rows
         int slackVar = 0;
         int artificialVar = 0;
         for (int i = 0; i < constraints.size(); i++) {
             LinearConstraint constraint = constraints.get(i);
             int row = getNumObjectiveFunctions() + i;
-
             // decision variable coefficients
             copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);
-
             // x-
             if (!restrictToNonNegative) {
-                matrix.setEntry(row, getSlackVariableOffset() - 1,
-                    getInvertedCoefficientSum(constraint.getCoefficients()));
+                matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients()));
             }
-
             // RHS
             matrix.setEntry(row, width - 1, constraint.getValue());
-
             // slack variables
             if (constraint.getRelationship() == Relationship.LEQ) {
-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
+                // slack
+                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);
             } else if (constraint.getRelationship() == Relationship.GEQ) {
-                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
+                // excess
+                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);
             }
-
             // artificial variables
-            if ((constraint.getRelationship() == Relationship.EQ) ||
-                    (constraint.getRelationship() == Relationship.GEQ)) {
+            if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
                 matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
                 matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
                 matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
             }
         }
-
         return matrix;
     }
 
@@ -258,12 +259,9 @@
      */
     private LinearConstraint normalize(final LinearConstraint constraint) {
         if (constraint.getValue() < 0) {
-            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),
-                                        constraint.getRelationship().oppositeRelationship(),
-                                        -1 * constraint.getValue());
+            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue());
         }
-        return new LinearConstraint(constraint.getCoefficients(),
-                                    constraint.getRelationship(), constraint.getValue());
+        return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
     }
 
     /**
@@ -328,10 +326,8 @@
         if (getNumObjectiveFunctions() == 1) {
             return;
         }
-
         List<Integer> columnsToDrop = new ArrayList<Integer>();
         columnsToDrop.add(0);
-
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
@@ -339,7 +335,6 @@
                 columnsToDrop.add(i);
             }
         }
-
         // non-basic artificial variables
         for (int i = 0; i < getNumArtificialVariables(); i++) {
           int col = i + getArtificialVariableOffset();
@@ -347,7 +342,6 @@
             columnsToDrop.add(col);
           }
         }
-
         double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
         for (int i = 1; i < getHeight(); i++) {
           int col = 0;
@@ -357,11 +351,9 @@
             }
           }
         }
-
         for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
           columnLabels.remove((int) columnsToDrop.get(i));
         }
-
         this.tableau = new Array2DRowRealMatrix(matrix);
         this.numArtificialVariables = 0;
     }
@@ -397,7 +389,6 @@
       int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
       Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
-
       Set<Integer> basicRows = new HashSet<Integer>();
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
       for (int i = 0; i < coefficients.length; i++) {
@@ -416,9 +407,7 @@
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
           } else {
               basicRows.add(basicRow);
-              coefficients[i] =
-                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
-                  (restrictToNonNegative ? 0 : mostNegative);
+                coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
           }
       }
       return new RealPointValuePair(coefficients, f.getValue(coefficients));
@@ -449,10 +438,8 @@
      * @param subtrahendRow row index
      * @param multiple multiplication factor
      */
-    protected void subtractRow(final int minuendRow, final int subtrahendRow,
-                               final double multiple) {
-        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)
-            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));
+    protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
+        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow).subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));
     }
 
     /**
@@ -471,7 +458,8 @@
         return tableau.getRowDimension();
     }
 
-    /** Get an entry of the tableau.
+    /**
+     * Get an entry of the tableau.
      * @param row row index
      * @param column column index
      * @return entry at (row, column)
@@ -480,13 +468,13 @@
         return tableau.getEntry(row, column);
     }
 
-    /** Set an entry of the tableau.
+    /**
+     * Set an entry of the tableau.
      * @param row row index
      * @param column column index
      * @param value for the entry
      */
-    protected final void setEntry(final int row, final int column,
-                                  final double value) {
+    protected final void setEntry(final int row, final int column, final double value) {
         tableau.setEntry(row, column, value);
     }
 
@@ -561,60 +549,46 @@
         return tableau.getData();
     }
 
-    /** {@inheritDoc} */
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public boolean equals(Object other) {
-
       if (this == other) {
         return true;
       }
-
       if (other instanceof SimplexTableau) {
           SimplexTableau rhs = (SimplexTableau) other;
-          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&
-                 (numDecisionVariables   == rhs.numDecisionVariables) &&
-                 (numSlackVariables      == rhs.numSlackVariables) &&
-                 (numArtificialVariables == rhs.numArtificialVariables) &&
-                 (epsilon                == rhs.epsilon) &&
-                 (maxUlps                == rhs.maxUlps) &&
-                 f.equals(rhs.f) &&
-                 constraints.equals(rhs.constraints) &&
-                 tableau.equals(rhs.tableau);
+            return (restrictToNonNegative == rhs.restrictToNonNegative) && (numDecisionVariables == rhs.numDecisionVariables) && (numSlackVariables == rhs.numSlackVariables) && (numArtificialVariables == rhs.numArtificialVariables) && (epsilon == rhs.epsilon) && (maxUlps == rhs.maxUlps) && f.equals(rhs.f) && constraints.equals(rhs.constraints) && tableau.equals(rhs.tableau);
       }
       return false;
     }
 
-    /** {@inheritDoc} */
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public int hashCode() {
-        return Boolean.valueOf(restrictToNonNegative).hashCode() ^
-               numDecisionVariables ^
-               numSlackVariables ^
-               numArtificialVariables ^
-               Double.valueOf(epsilon).hashCode() ^
-               maxUlps ^
-               f.hashCode() ^
-               constraints.hashCode() ^
-               tableau.hashCode();
+        return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ maxUlps ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();
     }
 
-    /** Serialize the instance.
+    /**
+     * Serialize the instance.
      * @param oos stream where object should be written
      * @throws IOException if object cannot be written to stream
      */
-    private void writeObject(ObjectOutputStream oos)
-        throws IOException {
+    private void writeObject(ObjectOutputStream oos) throws IOException {
         oos.defaultWriteObject();
         MatrixUtils.serializeRealMatrix(tableau, oos);
     }
 
-    /** Deserialize the instance.
+    /**
+     * Deserialize the instance.
      * @param ois stream from which the object should be read
      * @throws ClassNotFoundException if a class in the stream cannot be found
      * @throws IOException if object cannot be read from the stream
      */
-    private void readObject(ObjectInputStream ois)
-      throws ClassNotFoundException, IOException {
+    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
         ois.defaultReadObject();
         MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
     }

diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/math/math_63_buggy/src/main/java/org/apache/commons/math/util/MathUtils.java /mnt/D4JPatches/Manual2023/patches_plausible/Math/Math_63/Math_63_TBar_normal/src/main/java/org/apache/commons/math/util/MathUtils.java
--- /mnt/d4j_bug_info/buggyfiles/math/math_63_buggy/src/main/java/org/apache/commons/math/util/MathUtils.java	2022-11-20 04:09:32.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_plausible/Math/Math_63/Math_63_TBar_normal/src/main/java/org/apache/commons/math/util/MathUtils.java	2023-11-13 22:37:06.000000000 -0800
@@ -14,13 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.commons.math.util;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Arrays;
-
 import org.apache.commons.math.MathRuntimeException;
 import org.apache.commons.math.exception.util.Localizable;
 import org.apache.commons.math.exception.util.LocalizedFormats;
@@ -32,10 +30,13 @@
  */
 public final class MathUtils {
 
-    /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */
+    /**
+     * Smallest positive number such that 1 - EPSILON is not numerically equal to 1.
+     */
     public static final double EPSILON = 0x1.0p-53;
 
-    /** Safe minimum, such that 1 / SAFE_MIN does not overflow.
+    /**
+     * Safe minimum, such that 1 / SAFE_MIN does not overflow.
      * <p>In IEEE 754 arithmetic, this is also the smallest normalized
      * number 2<sup>-1022</sup>.</p>
      */
@@ -47,39 +48,50 @@
      */
     public static final double TWO_PI = 2 * FastMath.PI;
 
-    /** -1.0 cast as a byte. */
+    /**
+     * -1.0 cast as a byte.
+     */
     private static final byte  NB = (byte)-1;
 
-    /** -1.0 cast as a short. */
+    /**
+     * -1.0 cast as a short.
+     */
     private static final short NS = (short)-1;
 
-    /** 1.0 cast as a byte. */
+    /**
+     * 1.0 cast as a byte.
+     */
     private static final byte  PB = (byte)1;
 
-    /** 1.0 cast as a short. */
+    /**
+     * 1.0 cast as a short.
+     */
     private static final short PS = (short)1;
 
-    /** 0.0 cast as a byte. */
+    /**
+     * 0.0 cast as a byte.
+     */
     private static final byte  ZB = (byte)0;
 
-    /** 0.0 cast as a short. */
+    /**
+     * 0.0 cast as a short.
+     */
     private static final short ZS = (short)0;
 
-    /** Gap between NaN and regular numbers. */
+    /**
+     * Gap between NaN and regular numbers.
+     */
     private static final int NAN_GAP = 4 * 1024 * 1024;
 
-    /** Offset to order signed double numbers lexicographically. */
+    /**
+     * Offset to order signed double numbers lexicographically.
+     */
     private static final long SGN_MASK = 0x8000000000000000L;
 
-    /** All long-representable factorials */
-    private static final long[] FACTORIALS = new long[] {
-                       1l,                  1l,                   2l,
-                       6l,                 24l,                 120l,
-                     720l,               5040l,               40320l,
-                  362880l,            3628800l,            39916800l,
-               479001600l,         6227020800l,         87178291200l,
-           1307674368000l,     20922789888000l,     355687428096000l,
-        6402373705728000l, 121645100408832000l, 2432902008176640000l };
+    /**
+     * All long-representable factorials
+     */
+    private static final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };
 
     /**
      * Private Constructor
@@ -138,7 +150,6 @@
             ret = addAndCheck(b, a, pattern);
         } else {
             // assert a <= b
-
             if (a < 0) {
                 if (b < 0) {
                     // check for negative overflow
@@ -154,7 +165,6 @@
             } else {
                 // assert a >= 0
                 // assert b >= 0
-
                 // check for positive overflow
                 if (a <= Long.MAX_VALUE - b) {
                     ret = a + b;
@@ -202,7 +212,6 @@
         // Use symmetry for large k
         if (k > n / 2)
             return binomialCoefficient(n, n - k);
-
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
@@ -281,12 +290,10 @@
         if (n < 67) {
             return binomialCoefficient(n,k);
         }
-
         double result = 1d;
         for (int i = 1; i <= k; i++) {
              result *= (double)(n - k + i) / (double)i;
         }
-
         return FastMath.floor(result + 0.5);
     }
 
@@ -316,7 +323,6 @@
         if ((k == 1) || (k == n - 1)) {
             return FastMath.log(n);
         }
-
         /*
          * For values small enough to do exact integer computation,
          * return the log of the exact value
@@ -324,7 +330,6 @@
         if (n < 67) {
             return FastMath.log(binomialCoefficient(n,k));
         }
-
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
@@ -332,26 +337,21 @@
         if (n < 1030) {
             return FastMath.log(binomialCoefficientDouble(n, k));
         }
-
         if (k > n / 2) {
             return binomialCoefficientLog(n, n - k);
         }
-
         /*
          * Sum logs for values that could overflow
          */
         double logSum = 0;
-
         // n!/(n-k)!
         for (int i = n - k + 1; i <= n; i++) {
             logSum += FastMath.log(i);
         }
-
         // divide by k!
         for (int i = 2; i <= k; i++) {
             logSum -= FastMath.log(i);
         }
-
         return logSum;
     }
 
@@ -361,17 +361,12 @@
      * @param k the size of the subsets to be counted
      * @exception IllegalArgumentException if preconditions are not met.
      */
-    private static void checkBinomial(final int n, final int k)
-        throws IllegalArgumentException {
+    private static void checkBinomial(final int n, final int k) throws IllegalArgumentException {
         if (n < k) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,
-                n, k);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER, n, k);
         }
         if (n < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER,
-                  n);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);
         }
     }
 
@@ -414,7 +409,7 @@
      * @return {@code true} if the values are equal.
      */
     public static boolean equals(double x, double y) {
-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
+        return (Double.isNaN(EPSILON) && Double.isNaN(y)) || x == y;
     }
 
     /**
@@ -477,10 +472,8 @@
         // Check that "maxUlps" is non-negative and small enough so that
         // NaN won't compare as equal to anything (except another NaN).
         assert maxUlps > 0 && maxUlps < NAN_GAP;
-
         long xInt = Double.doubleToLongBits(x);
         long yInt = Double.doubleToLongBits(y);
-
         // Make lexicographically ordered as a two's-complement integer.
         if (xInt < 0) {
             xInt = SGN_MASK - xInt;
@@ -488,9 +481,7 @@
         if (yInt < 0) {
             yInt = SGN_MASK - yInt;
         }
-
         final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
-
         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
     }
 
@@ -583,13 +574,10 @@
      */
     public static long factorial(final int n) {
         if (n < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,
-                  n);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
         }
         if (n > 20) {
-            throw new ArithmeticException(
-                    "factorial value is too large to fit in a long");
+            throw new ArithmeticException("factorial value is too large to fit in a long");
         }
         return FACTORIALS[n];
     }
@@ -616,9 +604,7 @@
      */
     public static double factorialDouble(final int n) {
         if (n < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,
-                  n);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
         }
         if (n < 21) {
             return factorial(n);
@@ -641,9 +627,7 @@
      */
     public static double factorialLog(final int n) {
         if (n < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,
-                  n);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);
         }
         if (n < 21) {
             return FastMath.log(factorial(n));
@@ -689,9 +673,7 @@
         int v = q;
         if ((u == 0) || (v == 0)) {
             if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
-                throw MathRuntimeException.createArithmeticException(
-                        LocalizedFormats.GCD_OVERFLOW_32_BITS,
-                        p, q);
+                throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
             }
             return FastMath.abs(u) + FastMath.abs(v);
         }
@@ -702,33 +684,37 @@
         /* assert u!=0 && v!=0; */
         if (u > 0) {
             u = -u;
-        } // make u negative
+        }
+        // make u negative
         if (v > 0) {
             v = -v;
-        } // make v negative
+        }
+        // make v negative
         // B1. [Find power of 2]
         int k = 0;
-        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
+        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
+            // while u and v are
                                                             // both even...
             u /= 2;
             v /= 2;
-            k++; // cast out twos.
+            // cast out twos.
+            k++;
         }
         if (k == 31) {
-            throw MathRuntimeException.createArithmeticException(
-                    LocalizedFormats.GCD_OVERFLOW_32_BITS,
-                    p, q);
+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);
         }
         // B2. Initialize: u and v have been divided by 2^k and at least
         // one is odd.
-        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
+        int t = ((u & 1) == 1) ? v : -(u / 2);
         // t negative: u was odd, v may be even (t replaces v)
         // t positive: u was even, v is odd (t replaces u)
         do {
             /* assert u<0 && v<0; */
             // B4/B3: cast out twos from t.
-            while ((t & 1) == 0) { // while t is even..
-                t /= 2; // cast out twos
+            while ((t & 1) == 0) {
+                // while t is even..
+                // cast out twos
+                t /= 2;
             }
             // B5 [reset max(u,v)]
             if (t > 0) {
@@ -741,7 +727,8 @@
             // |u| larger: t positive (replace u)
             // |v| larger: t negative (replace v)
         } while (t != 0);
-        return -u * (1 << k); // gcd is u*2^k
+        // gcd is u*2^k
+        return -u * (1 << k);
     }
 
     /**
@@ -778,9 +765,7 @@
         long v = q;
         if ((u == 0) || (v == 0)) {
             if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){
-                throw MathRuntimeException.createArithmeticException(
-                        LocalizedFormats.GCD_OVERFLOW_64_BITS,
-                        p, q);
+                throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
             }
             return FastMath.abs(u) + FastMath.abs(v);
         }
@@ -791,33 +776,37 @@
         /* assert u!=0 && v!=0; */
         if (u > 0) {
             u = -u;
-        } // make u negative
+        }
+        // make u negative
         if (v > 0) {
             v = -v;
-        } // make v negative
+        }
+        // make v negative
         // B1. [Find power of 2]
         int k = 0;
-        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are
+        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {
+            // while u and v are
                                                             // both even...
             u /= 2;
             v /= 2;
-            k++; // cast out twos.
+            // cast out twos.
+            k++;
         }
         if (k == 63) {
-            throw MathRuntimeException.createArithmeticException(
-                    LocalizedFormats.GCD_OVERFLOW_64_BITS,
-                    p, q);
+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);
         }
         // B2. Initialize: u and v have been divided by 2^k and at least
         // one is odd.
-        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
+        long t = ((u & 1) == 1) ? v : -(u / 2);
         // t negative: u was odd, v may be even (t replaces v)
         // t positive: u was even, v is odd (t replaces u)
         do {
             /* assert u<0 && v<0; */
             // B4/B3: cast out twos from t.
-            while ((t & 1) == 0) { // while t is even..
-                t /= 2; // cast out twos
+            while ((t & 1) == 0) {
+                // while t is even..
+                // cast out twos
+                t /= 2;
             }
             // B5 [reset max(u,v)]
             if (t > 0) {
@@ -830,7 +819,8 @@
             // |u| larger: t positive (replace u)
             // |v| larger: t negative (replace v)
         } while (t != 0);
-        return -u * (1L << k); // gcd is u*2^k
+        // gcd is u*2^k
+        return -u * (1L << k);
     }
 
     /**
@@ -954,9 +944,7 @@
         }
         int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
         if (lcm == Integer.MIN_VALUE) {
-            throw MathRuntimeException.createArithmeticException(
-                LocalizedFormats.LCM_OVERFLOW_32_BITS,
-                a, b);
+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);
         }
         return lcm;
     }
@@ -989,9 +977,7 @@
         }
         long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));
         if (lcm == Long.MIN_VALUE){
-            throw MathRuntimeException.createArithmeticException(
-                LocalizedFormats.LCM_OVERFLOW_64_BITS,
-                a, b);
+            throw MathRuntimeException.createArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);
         }
         return lcm;
     }
@@ -1065,7 +1051,6 @@
                         ret = a * b;
                     } else {
                         throw new ArithmeticException(msg);
-
                     }
                 } else {
                     // assert b == 0
@@ -1074,7 +1059,6 @@
             } else if (a > 0) {
                 // assert a > 0
                 // assert b > 0
-
                 // check for positive overflow with positive a, positive b
                 if (a <= Long.MAX_VALUE / b) {
                     ret = a * b;
@@ -1099,21 +1083,17 @@
      * @since 2.0
      */
     public static double scalb(final double d, final int scaleFactor) {
-
         // handling of some important special cases
         if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
             return d;
         }
-
         // split the double in raw components
         final long bits     = Double.doubleToLongBits(d);
         final long exponent = bits & 0x7ff0000000000000L;
         final long rest     = bits & 0x800fffffffffffffL;
-
         // shift the exponent
         final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
         return Double.longBitsToDouble(newBits);
-
     }
 
     /**
@@ -1160,23 +1140,19 @@
       * @throws IllegalArgumentException if the target sum is infinite or NaN
       * @since 2.1
       */
-     public static double[] normalizeArray(double[] values, double normalizedSum)
-       throws ArithmeticException, IllegalArgumentException {
+    public static double[] normalizeArray(double[] values, double normalizedSum) throws ArithmeticException, IllegalArgumentException {
          if (Double.isInfinite(normalizedSum)) {
-             throw MathRuntimeException.createIllegalArgumentException(
-                     LocalizedFormats.NORMALIZE_INFINITE);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);
          }
          if (Double.isNaN(normalizedSum)) {
-             throw MathRuntimeException.createIllegalArgumentException(
-                     LocalizedFormats.NORMALIZE_NAN);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);
          }
          double sum = 0d;
          final int len = values.length;
          double[] out = new double[len];
          for (int i = 0; i < len; i++) {
              if (Double.isInfinite(values[i])) {
-                 throw MathRuntimeException.createArithmeticException(
-                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
+                throw MathRuntimeException.createArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
              }
              if (!Double.isNaN(values[i])) {
                  sum += values[i];
@@ -1222,10 +1198,7 @@
      */
     public static double round(double x, int scale, int roundingMethod) {
         try {
-            return (new BigDecimal
-                   (Double.toString(x))
-                   .setScale(scale, roundingMethod))
-                   .doubleValue();
+            return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();
         } catch (NumberFormatException ex) {
             if (Double.isInfinite(x)) {
                 return x;
@@ -1278,8 +1251,7 @@
      * @return the rounded value.
      * @since 1.1
      */
-    private static double roundUnscaled(double unscaled, double sign,
-        int roundingMethod) {
+    private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {
         switch (roundingMethod) {
         case BigDecimal.ROUND_CEILING :
             if (sign == -1) {
@@ -1298,7 +1270,8 @@
                 unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             }
             break;
-        case BigDecimal.ROUND_HALF_DOWN : {
+            case BigDecimal.ROUND_HALF_DOWN:
+                {
             unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);
             double fraction = unscaled - FastMath.floor(unscaled);
             if (fraction > 0.5) {
@@ -1308,7 +1281,8 @@
             }
             break;
         }
-        case BigDecimal.ROUND_HALF_EVEN : {
+            case BigDecimal.ROUND_HALF_EVEN:
+                {
             double fraction = unscaled - FastMath.floor(unscaled);
             if (fraction > 0.5) {
                 unscaled = FastMath.ceil(unscaled);
@@ -1316,16 +1290,18 @@
                 unscaled = FastMath.floor(unscaled);
             } else {
                 // The following equality test is intentional and needed for rounding purposes
-                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math
-                    .floor(unscaled) / 2.0)) { // even
+                        if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math.floor(unscaled) / 2.0)) {
+                            // even
                     unscaled = FastMath.floor(unscaled);
-                } else { // odd
+                        } else {
+                            // odd
                     unscaled = FastMath.ceil(unscaled);
                 }
             }
             break;
         }
-        case BigDecimal.ROUND_HALF_UP : {
+            case BigDecimal.ROUND_HALF_UP:
+                {
             unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);
             double fraction = unscaled - FastMath.floor(unscaled);
             if (fraction >= 0.5) {
@@ -1344,17 +1320,7 @@
             unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));
             break;
         default :
-            throw MathRuntimeException.createIllegalArgumentException(
-                  LocalizedFormats.INVALID_ROUNDING_METHOD,
-                  roundingMethod,
-                  "ROUND_CEILING",     BigDecimal.ROUND_CEILING,
-                  "ROUND_DOWN",        BigDecimal.ROUND_DOWN,
-                  "ROUND_FLOOR",       BigDecimal.ROUND_FLOOR,
-                  "ROUND_HALF_DOWN",   BigDecimal.ROUND_HALF_DOWN,
-                  "ROUND_HALF_EVEN",   BigDecimal.ROUND_HALF_EVEN,
-                  "ROUND_HALF_UP",     BigDecimal.ROUND_HALF_UP,
-                  "ROUND_UNNECESSARY", BigDecimal.ROUND_UNNECESSARY,
-                  "ROUND_UP",          BigDecimal.ROUND_UP);
+                throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD, roundingMethod, "ROUND_CEILING", BigDecimal.ROUND_CEILING, "ROUND_DOWN", BigDecimal.ROUND_DOWN, "ROUND_FLOOR", BigDecimal.ROUND_FLOOR, "ROUND_HALF_DOWN", BigDecimal.ROUND_HALF_DOWN, "ROUND_HALF_EVEN", BigDecimal.ROUND_HALF_EVEN, "ROUND_HALF_UP", BigDecimal.ROUND_HALF_UP, "ROUND_UNNECESSARY", BigDecimal.ROUND_UNNECESSARY, "ROUND_UP", BigDecimal.ROUND_UP);
         }
         return unscaled;
     }
@@ -1515,15 +1481,10 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static int pow(final int k, int e)
-        throws IllegalArgumentException {
-
+    public static int pow(final int k, int e) throws IllegalArgumentException {
         if (e < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         int result = 1;
         int k2p    = k;
         while (e != 0) {
@@ -1533,9 +1494,7 @@
             k2p *= k2p;
             e = e >> 1;
         }
-
         return result;
-
     }
 
     /**
@@ -1545,15 +1504,10 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static int pow(final int k, long e)
-        throws IllegalArgumentException {
-
+    public static int pow(final int k, long e) throws IllegalArgumentException {
         if (e < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         int result = 1;
         int k2p    = k;
         while (e != 0) {
@@ -1563,9 +1517,7 @@
             k2p *= k2p;
             e = e >> 1;
         }
-
         return result;
-
     }
 
     /**
@@ -1575,15 +1527,10 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static long pow(final long k, int e)
-        throws IllegalArgumentException {
-
+    public static long pow(final long k, int e) throws IllegalArgumentException {
         if (e < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         long result = 1l;
         long k2p    = k;
         while (e != 0) {
@@ -1593,9 +1540,7 @@
             k2p *= k2p;
             e = e >> 1;
         }
-
         return result;
-
     }
 
     /**
@@ -1605,15 +1550,10 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static long pow(final long k, long e)
-        throws IllegalArgumentException {
-
+    public static long pow(final long k, long e) throws IllegalArgumentException {
         if (e < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         long result = 1l;
         long k2p    = k;
         while (e != 0) {
@@ -1623,9 +1563,7 @@
             k2p *= k2p;
             e = e >> 1;
         }
-
         return result;
-
     }
 
     /**
@@ -1635,17 +1573,11 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static BigInteger pow(final BigInteger k, int e)
-        throws IllegalArgumentException {
-
+    public static BigInteger pow(final BigInteger k, int e) throws IllegalArgumentException {
         if (e < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         return k.pow(e);
-
     }
 
     /**
@@ -1655,15 +1587,10 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static BigInteger pow(final BigInteger k, long e)
-        throws IllegalArgumentException {
-
+    public static BigInteger pow(final BigInteger k, long e) throws IllegalArgumentException {
         if (e < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         BigInteger result = BigInteger.ONE;
         BigInteger k2p    = k;
         while (e != 0) {
@@ -1673,9 +1600,7 @@
             k2p = k2p.multiply(k2p);
             e = e >> 1;
         }
-
         return result;
-
     }
 
     /**
@@ -1685,15 +1610,10 @@
      * @return k<sup>e</sup>
      * @exception IllegalArgumentException if e is negative
      */
-    public static BigInteger pow(final BigInteger k, BigInteger e)
-        throws IllegalArgumentException {
-
+    public static BigInteger pow(final BigInteger k, BigInteger e) throws IllegalArgumentException {
         if (e.compareTo(BigInteger.ZERO) < 0) {
-            throw MathRuntimeException.createIllegalArgumentException(
-                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,
-                k, e);
+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.POWER_NEGATIVE_PARAMETERS, k, e);
         }
-
         BigInteger result = BigInteger.ONE;
         BigInteger k2p    = k;
         while (!BigInteger.ZERO.equals(e)) {
@@ -1703,9 +1623,7 @@
             k2p = k2p.multiply(k2p);
             e = e.shiftRight(1);
         }
-
         return result;
-
     }
 
     /**
@@ -1804,9 +1722,14 @@
      * Specification of ordering direction.
      */
     public static enum OrderDirection {
-        /** Constant for increasing direction. */
+
+        /**
+         * Constant for increasing direction.
+         */
         INCREASING,
-        /** Constant for decreasing direction. */
+        /**
+         * Constant for decreasing direction.
+         */
         DECREASING
     }
 
@@ -1821,7 +1744,6 @@
     public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {
         double previous = val[0];
         boolean ok = true;
-
         int max = val.length;
         for (int i = 1; i < max; i++) {
             switch (dir) {
@@ -1851,7 +1773,6 @@
                 // Should never happen.
                 throw new IllegalArgumentException();
             }
-
             if (!ok) {
                 throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);
             }
@@ -1982,5 +1903,4 @@
     }
     return norm;
 }
-
 }
Only in /mnt/D4JPatches/Manual2023/patches_plausible/Math/Math_63/Math_63_TBar_normal/src/main/java/org/apache/commons/math/util: MathUtils.java.orig

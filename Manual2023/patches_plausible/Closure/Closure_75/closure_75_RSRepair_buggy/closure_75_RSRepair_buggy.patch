diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/closure/closure_75_buggy/src/com/google/javascript/jscomp/NodeUtil.java /mnt/D4JPatches/Manual2023/patches_plausible/Closure/Closure_75/closure_75_RSRepair_buggy/src/com/google/javascript/jscomp/NodeUtil.java
--- /mnt/d4j_bug_info/buggyfiles/closure/closure_75_buggy/src/com/google/javascript/jscomp/NodeUtil.java	2022-11-20 04:09:31.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_plausible/Closure/Closure_75/closure_75_RSRepair_buggy/src/com/google/javascript/jscomp/NodeUtil.java	2023-11-13 22:37:06.000000000 -0800
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.javascript.jscomp;
 
 import com.google.common.base.Preconditions;
@@ -28,7 +27,6 @@
 import com.google.javascript.rhino.jstype.FunctionType;
 import com.google.javascript.rhino.jstype.JSType;
 import com.google.javascript.rhino.jstype.TernaryValue;
-
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -36,12 +34,10 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.Nullable;
 
 /**
  * NodeUtil contains utilities that get properties from the Node object.
- *
  */
 public final class NodeUtil {
 
@@ -49,19 +45,14 @@
 
   // TODO(user): Eliminate this class and make all of the static methods
   // instance methods of com.google.javascript.rhino.Node.
-
-  /** the set of builtin constructors that don't have side effects. */
-  private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =
-      new HashSet<String>(Arrays.asList(
-        "Array",
-        "Date",
-        "Error",
-        "Object",
-        "RegExp",
-        "XMLHttpRequest"));
+    /**
+     * the set of builtin constructors that don't have side effects.
+     */
+    private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS = new HashSet<String>(Arrays.asList("Array", "Date", "Error", "Object", "RegExp", "XMLHttpRequest"));
 
   // Utility class; do not instantiate.
-  private NodeUtil() {}
+    private NodeUtil() {
+    }
 
   /**
    * Gets the boolean value of a node that represents a expression. This method
@@ -78,19 +69,21 @@
       case Token.NOT:
         TernaryValue value = getImpureBooleanValue(n.getLastChild());
         return value.not();
-      case Token.AND: {
+            case Token.AND:
+                {
         TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
         TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.and(rhs);
       }
-      case Token.OR:  {
+            case Token.OR:
+                {
         TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
         TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
         return lhs.or(rhs);
       }
-      case Token.HOOK:  {
-        TernaryValue trueValue = getImpureBooleanValue(
-            n.getFirstChild().getNext());
+            case Token.HOOK:
+                {
+                    TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());
         TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
         if (trueValue.equals(falseValue)) {
           return trueValue;
@@ -102,7 +95,6 @@
       case Token.OBJECTLIT:
         // ignoring side-effects
         return TernaryValue.TRUE;
-
       default:
         return getPureBooleanValue(n);
     }
@@ -118,22 +110,17 @@
     switch (n.getType()) {
       case Token.STRING:
         return TernaryValue.forBoolean(n.getString().length() > 0);
-
       case Token.NUMBER:
         return TernaryValue.forBoolean(n.getDouble() != 0);
-
       case Token.NOT:
         return getPureBooleanValue(n.getLastChild()).not();
-
       case Token.NULL:
       case Token.FALSE:
       case Token.VOID:
         return TernaryValue.FALSE;
-
       case Token.NAME:
         String name = n.getString();
-        if ("undefined".equals(name)
-            || "NaN".equals(name)) {
+                if ("undefined".equals(name) || "NaN".equals(name)) {
           // We assume here that programs don't change the value of the keyword
           // undefined to something other than the value undefined.
           return TernaryValue.FALSE;
@@ -141,22 +128,18 @@
           return TernaryValue.TRUE;
         }
         break;
-
       case Token.TRUE:
       case Token.REGEXP:
         return TernaryValue.TRUE;
-
       case Token.ARRAYLIT:
       case Token.OBJECTLIT:
         if (!mayHaveSideEffects(n)) {
           return TernaryValue.TRUE;
         }
     }
-
     return TernaryValue.UNKNOWN;
   }
 
-
   /**
    * Gets the value of a node as a String, or null if it cannot be converted.
    * When it returns a non-null String, this method effectively emulates the
@@ -167,45 +150,36 @@
     switch (n.getType()) {
       case Token.STRING:
         return n.getString();
-
       case Token.NAME:
         String name = n.getString();
-        if ("undefined".equals(name)
-            || "Infinity".equals(name)
-            || "NaN".equals(name)) {
+                if ("undefined".equals(name) || "Infinity".equals(name) || "NaN".equals(name)) {
           return name;
         }
         break;
-
       case Token.NUMBER:
         double value = n.getDouble();
         long longValue = (long) value;
-
         // Return "1" instead of "1.0"
         if (longValue == value) {
           return Long.toString(longValue);
         } else {
           return Double.toString(n.getDouble());
         }
-
       case Token.FALSE:
       case Token.TRUE:
       case Token.NULL:
         return Node.tokenToName(n.getType());
-
       case Token.VOID:
         return "undefined";
-
       case Token.NOT:
         TernaryValue child = getPureBooleanValue(n.getFirstChild());
         if (child != TernaryValue.UNKNOWN) {
-          return child.toBoolean(true) ? "false" : "true"; // reversed.
+                    // reversed.
+                    return child.toBoolean(true) ? "false" : "true";
         }
         break;
-
       case Token.ARRAYLIT:
         return arrayToString(n);
-
       case Token.OBJECTLIT:
         return "[object Object]";
     }
@@ -221,8 +195,7 @@
    * @return The string representation.
    */
   static String getArrayElementStringValue(Node n) {
-    return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY)
-        ? "" : getStringValue(n);
+        return (NodeUtil.isNullOrUndefined(n) || n.getType() == Token.EMPTY) ? "" : getStringValue(n);
   }
 
   static String arrayToString(Node literal) {
@@ -239,7 +212,6 @@
         result.append(',');
       }
       result.append(childValue);
-
       nextSlot++;
     }
     return result.toString();
@@ -254,21 +226,17 @@
     switch (n.getType()) {
       case Token.TRUE:
         return 1.0;
-
       case Token.FALSE:
       case Token.NULL:
         return 0.0;
-
       case Token.NUMBER:
         return n.getDouble();
-
       case Token.VOID:
         if (mayHaveSideEffects(n.getFirstChild())) {
           return null;
         } else {
           return Double.NaN;
         }
-
       case Token.NAME:
         // Check for known constants
         String name = n.getString();
@@ -282,45 +250,36 @@
           return Double.POSITIVE_INFINITY;
         }
         return null;
-
       case Token.NEG:
-        if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME
-            && n.getFirstChild().getString().equals("Infinity")) {
+                if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME && n.getFirstChild().getString().equals("Infinity")) {
           return Double.NEGATIVE_INFINITY;
         }
         return null;
-
       case Token.NOT:
         TernaryValue child = getPureBooleanValue(n.getFirstChild());
         if (child != TernaryValue.UNKNOWN) {
-          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.
+                    // reversed.
+                    return child.toBoolean(true) ? 0.0 : 1.0;
         }
         break;
-
       case Token.STRING:
-        return getStringNumberValue(n.getString());
-
+                break;
       case Token.ARRAYLIT:
       case Token.OBJECTLIT:
         String value = getStringValue(n);
         return value != null ? getStringNumberValue(value) : null;
     }
-
     return null;
   }
 
   static Double getStringNumberValue(String rawJsString) {
       // vertical tab is not always whitespace
-
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
     if (s.length() == 0) {
       return 0.0;
     }
-
-    if (s.length() > 2
-        && s.charAt(0) == '0'
-        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
+        if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
       // Attempt to convert hex numbers.
       try {
         return Double.valueOf(Integer.parseInt(s.substring(2), 16));
@@ -328,23 +287,15 @@
         return Double.NaN;
       }
     }
-
-    if (s.length() > 3
-        && (s.charAt(0) == '-' || s.charAt(0) == '+')
-        && s.charAt(1) == '0'
-        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
+        if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
       // hex numbers with explicit signs vary between browsers.
       return null;
     }
-
     // FireFox and IE treat the "Infinity" differently. FireFox is case
     // insensitive, but IE treats "infinity" as NaN.  So leave it alone.
-    if (s.equals("infinity")
-        || s.equals("-infinity")
-        || s.equals("+infinity")) {
+        if (s.equals("infinity") || s.equals("-infinity") || s.equals("+infinity")) {
       return null;
     }
-
     try {
       return Double.parseDouble(s);
     } catch (NumberFormatException e) {
@@ -355,12 +306,10 @@
   static String trimJsWhiteSpace(String s) {
     int start = 0;
     int end = s.length();
-    while (end > 0
-        && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {
+        while (end > 0 && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {
       end--;
     }
-    while (start < end
-        && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {
+        while (start < end && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {
       start++;
     }
     return s.substring(start, end);
@@ -371,21 +320,30 @@
    */
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
-      case '\u000B': // <VT>
+            case // <VT>
+            '\u000B':
         return TernaryValue.TRUE;
-      case ' ': // <SP>
-      case '\n': // <LF>
-      case '\r': // <CR>
-      case '\t': // <TAB>
-      case '\u00A0': // <NBSP>
-      case '\u000C': // <FF>
-      case '\u2028': // <LS>
-      case '\u2029': // <PS>
-      case '\uFEFF': // <BOM>
+            // <SP>
+            case ' ':
+            // <LF>
+            case '\n':
+            // <CR>
+            case '\r':
+            // <TAB>
+            case '\t':
+            // <NBSP>
+            case '\u00A0':
+            // <FF>
+            case '\u000C':
+            // <LS>
+            case '\u2028':
+            // <PS>
+            case '\u2029':
+            case // <BOM>
+            '\uFEFF':
         return TernaryValue.TRUE;
       default:
-        return (Character.getType(c) == Character.SPACE_SEPARATOR)
-            ? TernaryValue.TRUE : TernaryValue.FALSE;
+                return (Character.getType(c) == Character.SPACE_SEPARATOR) ? TernaryValue.TRUE : TernaryValue.FALSE;
     }
   }
 
@@ -412,12 +370,10 @@
         // var name = function() ...
         // var name2 = function name1() ...
         return parent.getString();
-
       case Token.ASSIGN:
         // qualified.name = function() ...
         // qualified.name2 = function name1() ...
         return parent.getFirstChild().getQualifiedName();
-
       default:
         // function name() ...
         return name != null && name.length() != 0 ? name : null;
@@ -444,7 +400,6 @@
     if (name != null) {
       return name;
     }
-
     // Check for the form { 'x' : function() { } }
     Node parent = n.getParent();
     switch (parent.getType()) {
@@ -456,11 +411,9 @@
       case Token.NUMBER:
         return getStringValue(parent);
     }
-
     return null;
   }
 
-
   /**
    * Returns true if this is an immutable value.
    */
@@ -481,11 +434,8 @@
         String name = n.getString();
         // We assume here that programs don't change the value of the keyword
         // undefined to something other than the value undefined.
-        return "undefined".equals(name)
-            || "Infinity".equals(name)
-            || "NaN".equals(name);
+                return "undefined".equals(name) || "Infinity".equals(name) || "NaN".equals(name);
     }
-
     return false;
   }
 
@@ -514,38 +464,30 @@
   static boolean isLiteralValue(Node n, boolean includeFunctions) {
     switch (n.getType()) {
       case Token.ARRAYLIT:
-        for (Node child = n.getFirstChild(); child != null;
-             child = child.getNext()) {
-          if (child.getType() != Token.EMPTY
-              && !isLiteralValue(child, includeFunctions)) {
+                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
+                    if (child.getType() != Token.EMPTY && !isLiteralValue(child, includeFunctions)) {
             return false;
           }
         }
         return true;
-
       case Token.REGEXP:
         // Return true only if all children are const.
-        for (Node child = n.getFirstChild(); child != null;
-             child = child.getNext()) {
+                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
           if (!isLiteralValue(child, includeFunctions)) {
             return false;
           }
         }
         return true;
-
       case Token.OBJECTLIT:
         // Return true only if all values are const.
-        for (Node child = n.getFirstChild(); child != null;
-             child = child.getNext()) {
+                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {
           if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {
             return false;
           }
         }
         return true;
-
       case Token.FUNCTION:
         return includeFunctions && !NodeUtil.isFunctionDeclaration(n);
-
       default:
         return isImmutableValue(n);
     }
@@ -564,7 +506,6 @@
       case Token.TRUE:
       case Token.FALSE:
         return true;
-
       // Binary operators are only valid if both children are valid.
       case Token.ADD:
       case Token.BITAND:
@@ -586,15 +527,12 @@
       case Token.SHNE:
       case Token.SUB:
       case Token.URSH:
-        return isValidDefineValue(val.getFirstChild(), defines)
-            && isValidDefineValue(val.getLastChild(), defines);
-
+                return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
       case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
-
       // Names are valid if and only if they are defines themselves.
       case Token.NAME:
       case Token.GETPROP:
@@ -614,7 +552,6 @@
     if (block.getType() != Token.BLOCK) {
       return false;
     }
-
     for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {
       if (n.getType() != Token.EMPTY) {
         return false;
@@ -664,7 +601,6 @@
       case Token.NEG:
       case Token.URSH:
         return true;
-
       default:
         return false;
     }
@@ -677,8 +613,7 @@
    * @return Newly created EXPR node with the child as subexpression.
    */
   public static Node newExpr(Node child) {
-    Node expr = new Node(Token.EXPR_RESULT, child)
-        .copyInformationFrom(child);
+        Node expr = new Node(Token.EXPR_RESULT, child).copyInformationFrom(child);
     return expr;
   }
 
@@ -713,8 +648,7 @@
    * mutable objects (like object literals) change state. Otherwise, we assume
    * that they have no side effects.
    */
-  private static boolean checkForStateChangeHelper(
-      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {
+    private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) {
     // Rather than id which ops may have side effects, id the ones
     // that we know to be safe
     switch (n.getType()) {
@@ -737,55 +671,48 @@
       case Token.TRY:
       case Token.EMPTY:
         break;
-
       // Throws are by definition side effects
       case Token.THROW:
         return true;
-
       case Token.OBJECTLIT:
         if (checkForNewObjects) {
           return true;
         }
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
-          if (checkForStateChangeHelper(
-                  c.getFirstChild(), checkForNewObjects, compiler)) {
+                    if (checkForStateChangeHelper(c.getFirstChild(), checkForNewObjects, compiler)) {
             return true;
           }
         }
         return false;
-
       case Token.ARRAYLIT:
       case Token.REGEXP:
         if (checkForNewObjects) {
           return true;
         }
         break;
-
-      case Token.VAR:    // empty var statement (no declaration)
-      case Token.NAME:   // variable by itself
+            // empty var statement (no declaration)
+            case Token.VAR:
+            case // variable by itself
+            Token.NAME:
         if (n.getFirstChild() != null) {
           return true;
         }
         break;
-
       case Token.FUNCTION:
         // Function expressions don't have side-effects, but function
         // declarations change the namespace. Either way, we don't need to
         // check the children, since they aren't executed at declaration time.
         return checkForNewObjects || !isFunctionExpression(n);
-
       case Token.NEW:
         if (checkForNewObjects) {
           return true;
         }
-
         if (!constructorCallHasSideEffects(n)) {
           // loop below will see if the constructor parameters have
           // side-effects
           break;
         }
         return true;
-
       case Token.CALL:
         // calls to functions that have no side effects have the no
         // side effect property set.
@@ -795,29 +722,22 @@
           break;
         }
         return true;
-
       default:
         if (isSimpleOperatorType(n.getType())) {
           break;
         }
-
         if (isAssignmentOp(n)) {
           Node assignTarget = n.getFirstChild();
           if (isName(assignTarget)) {
             return true;
           }
-
           // Assignments will have side effects if
           // a) The RHS has side effects, or
           // b) The LHS has side effects, or
           // c) A name on the LHS will exist beyond the life of this statement.
-          if (checkForStateChangeHelper(
-                  n.getFirstChild(), checkForNewObjects, compiler) ||
-              checkForStateChangeHelper(
-                  n.getLastChild(), checkForNewObjects, compiler)) {
+                    if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) {
             return true;
           }
-
           if (isGet(assignTarget)) {
             // If the object being assigned to is a local object, don't
             // consider this a side-effect as it can't be referenced
@@ -827,7 +747,6 @@
             if (evaluatesToLocalValue(current)) {
               return false;
             }
-
             // A literal value as defined by "isLiteralValue" is guaranteed
             // not to be an alias, or any components which are aliases of
             // other objects.
@@ -836,7 +755,6 @@
             while (isGet(current)) {
               current = current.getFirstChild();
             }
-
             return !isLiteralValue(current, true);
           } else {
             // TODO(johnlenz): remove this code and make this an exception. This
@@ -845,16 +763,13 @@
             return !isLiteralValue(assignTarget, true);
           }
         }
-
         return true;
     }
-
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
       if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {
         return true;
       }
     }
-
     return false;
   }
 
@@ -867,38 +782,30 @@
     return constructorCallHasSideEffects(callNode, null);
   }
 
-  static boolean constructorCallHasSideEffects(
-      Node callNode, AbstractCompiler compiler) {
+    static boolean constructorCallHasSideEffects(Node callNode, AbstractCompiler compiler) {
     if (callNode.getType() != Token.NEW) {
-      throw new IllegalStateException(
-          "Expected NEW node, got " + Token.name(callNode.getType()));
+            throw new IllegalStateException("Expected NEW node, got " + Token.name(callNode.getType()));
     }
-
     if (callNode.isNoSideEffectsCall()) {
       return false;
     }
-
     Node nameNode = callNode.getFirstChild();
-    if (nameNode.getType() == Token.NAME &&
-        CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {
+        if (nameNode.getType() == Token.NAME && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {
       return false;
     }
-
     return true;
   }
 
   // A list of built-in object creation or primitive type cast functions that
   // can also be called as constructors but lack side-effects.
   // TODO(johnlenz): consider adding an extern annotation for this.
-  private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS =
-      ImmutableSet.of(
-          "Object", "Array", "String", "Number", "Boolean", "RegExp", "Error");
-  private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS =
-      ImmutableSet.of("toString", "valueOf");
-  private static final Set<String> REGEXP_METHODS =
-      ImmutableSet.of("test", "exec");
-  private static final Set<String> STRING_REGEXP_METHODS =
-      ImmutableSet.of("match", "replace", "search", "split");
+    private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS = ImmutableSet.of("Object", "Array", "String", "Number", "Boolean", "RegExp", "Error");
+
+    private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS = ImmutableSet.of("toString", "valueOf");
+
+    private static final Set<String> REGEXP_METHODS = ImmutableSet.of("test", "exec");
+
+    private static final Set<String> STRING_REGEXP_METHODS = ImmutableSet.of("match", "replace", "search", "split");
 
   /**
    * Returns true if calls to this function have side effects.
@@ -916,19 +823,14 @@
    * @param compiler A compiler object to provide program state changing
    *     context information. Can be null.
    */
-  static boolean functionCallHasSideEffects(
-      Node callNode, @Nullable AbstractCompiler compiler) {
+    static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {
     if (callNode.getType() != Token.CALL) {
-      throw new IllegalStateException(
-          "Expected CALL node, got " + Token.name(callNode.getType()));
+            throw new IllegalStateException("Expected CALL node, got " + Token.name(callNode.getType()));
     }
-
     if (callNode.isNoSideEffectsCall()) {
       return false;
     }
-
     Node nameNode = callNode.getFirstChild();
-
     // Built-in functions with no side effects.
     if (nameNode.getType() == Token.NAME) {
       String name = nameNode.getString();
@@ -936,17 +838,12 @@
         return false;
       }
     } else if (nameNode.getType() == Token.GETPROP) {
-      if (callNode.hasOneChild()
-          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
-                nameNode.getLastChild().getString())) {
+            if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {
         return false;
       }
-
-      if (callNode.isOnlyModifiesThisCall()
-          && evaluatesToLocalValue(nameNode.getFirstChild())) {
+            if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {
         return false;
       }
-
       // Functions in the "Math" namespace have no side effects.
       if (nameNode.getFirstChild().getType() == Token.NAME) {
         String namespaceName = nameNode.getFirstChild().getString();
@@ -954,23 +851,16 @@
           return false;
         }
       }
-
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
-        if (nameNode.getFirstChild().getType() == Token.REGEXP
-            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
+                if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
           return false;
-        } else if (nameNode.getFirstChild().getType() == Token.STRING
-            && STRING_REGEXP_METHODS.contains(
-                nameNode.getLastChild().getString())) {
+                } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
           Node param = nameNode.getNext();
-          if (param != null &&
-              (param.getType() == Token.STRING
-                  || param.getType() == Token.REGEXP))
+                    if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))
           return false;
         }
       }
     }
-
     return true;
   }
 
@@ -1005,7 +895,6 @@
     if (isAssignmentOp(n)) {
       return true;
     }
-
     switch(n.getType()) {
       case Token.DELPROP:
       case Token.DEC:
@@ -1049,27 +938,22 @@
         return true;
       case Token.NAME:
         // Non-constant names values may have been changed.
-        return !isConstantName(n)
-            && !knownConstants.contains(n.getString());
-
+                return !isConstantName(n) && !knownConstants.contains(n.getString());
       // Properties on constant NAMEs can still be side-effected.
       case Token.GETPROP:
       case Token.GETELEM:
         return true;
-
       case Token.FUNCTION:
         // Function expression are not changed by side-effects,
         // and function declarations are not part of expressions.
         Preconditions.checkState(isFunctionExpression(n));
         return false;
     }
-
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
       if (canBeSideEffected(c, knownConstants)) {
         return true;
       }
     }
-
     return false;
   }
 
@@ -1092,7 +976,8 @@
    */
   static int precedence(int type) {
     switch (type) {
-      case Token.COMMA:  return 0;
+            case Token.COMMA:
+                return 0;
       case Token.ASSIGN_BITOR:
       case Token.ASSIGN_BITXOR:
       case Token.ASSIGN_BITAND:
@@ -1104,31 +989,44 @@
       case Token.ASSIGN_MUL:
       case Token.ASSIGN_DIV:
       case Token.ASSIGN_MOD:
-      case Token.ASSIGN: return 1;
-      case Token.HOOK:   return 2;  // ?: operator
-      case Token.OR:     return 3;
-      case Token.AND:    return 4;
-      case Token.BITOR:  return 5;
-      case Token.BITXOR: return 6;
-      case Token.BITAND: return 7;
+            case Token.ASSIGN:
+                return 1;
+            // ?: operator
+            case Token.HOOK:
+                return 2;
+            case Token.OR:
+                return 3;
+            case Token.AND:
+                return 4;
+            case Token.BITOR:
+                return 5;
+            case Token.BITXOR:
+                return 6;
+            case Token.BITAND:
+                return 7;
       case Token.EQ:
       case Token.NE:
       case Token.SHEQ:
-      case Token.SHNE:   return 8;
+            case Token.SHNE:
+                return 8;
       case Token.LT:
       case Token.GT:
       case Token.LE:
       case Token.GE:
       case Token.INSTANCEOF:
-      case Token.IN:     return 9;
+            case Token.IN:
+                return 9;
       case Token.LSH:
       case Token.RSH:
-      case Token.URSH:   return 10;
+            case Token.URSH:
+                return 10;
       case Token.SUB:
-      case Token.ADD:    return 11;
+            case Token.ADD:
+                return 11;
       case Token.MUL:
       case Token.MOD:
-      case Token.DIV:    return 12;
+            case Token.DIV:
+                return 12;
       case Token.INC:
       case Token.DEC:
       case Token.NEW:
@@ -1138,8 +1036,8 @@
       case Token.NOT:
       case Token.BITNOT:
       case Token.POS:
-      case Token.NEG:    return 13;
-
+            case Token.NEG:
+                return 13;
       case Token.ARRAYLIT:
       case Token.CALL:
       case Token.EMPTY:
@@ -1159,10 +1057,8 @@
       case Token.THIS:
       case Token.TRUE:
         return 15;
-
-      default: throw new Error("Unknown precedence for " +
-                               Node.tokenToName(type) +
-                               " (type " + type + ")");
+            default:
+                throw new Error("Unknown precedence for " + Node.tokenToName(type) + " (type " + type + ")");
     }
   }
 
@@ -1177,24 +1073,22 @@
         return valueCheck(n.getLastChild(), p);
       case Token.AND:
       case Token.OR:
-        return valueCheck(n.getFirstChild(), p)
-            && valueCheck(n.getLastChild(), p);
+                return valueCheck(n.getFirstChild(), p) && valueCheck(n.getLastChild(), p);
       case Token.HOOK:
-        return valueCheck(n.getFirstChild().getNext(), p)
-            && valueCheck(n.getLastChild(), p);
+                return valueCheck(n.getFirstChild().getNext(), p) && valueCheck(n.getLastChild(), p);
       default:
         return p.apply(n);
     }
   }
 
   static class NumbericResultPredicate implements Predicate<Node> {
+
     public boolean apply(Node n) {
       return isNumericResultHelper(n);
     }
   }
 
-  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =
-      new NumbericResultPredicate();
+    static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE = new NumbericResultPredicate();
 
   /**
    * Returns true if the result of node evaluation is always a number
@@ -1206,8 +1100,7 @@
   static boolean isNumericResultHelper(Node n) {
     switch (n.getType()) {
       case Token.ADD:
-        return !mayBeString(n.getFirstChild())
-            && !mayBeString(n.getLastChild());
+                return !mayBeString(n.getFirstChild()) && !mayBeString(n.getLastChild());
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
@@ -1240,13 +1133,13 @@
   }
 
   static class BooleanResultPredicate implements Predicate<Node> {
+
     public boolean apply(Node n) {
       return isBooleanResultHelper(n);
     }
   }
 
-  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =
-      new BooleanResultPredicate();
+    static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE = new BooleanResultPredicate();
 
   /**
    * @return Whether the result of node evaluation is always a boolean
@@ -1301,13 +1194,13 @@
   }
 
   static class MayBeStringResultPredicate implements Predicate<Node> {
+
     public boolean apply(Node n) {
       return mayBeStringHelper(n);
     }
   }
 
-  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =
-      new MayBeStringResultPredicate();
+    static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE = new MayBeStringResultPredicate();
 
   /**
    * @returns Whether the results is possibly a string.
@@ -1325,8 +1218,7 @@
   }
 
   static boolean mayBeStringHelper(Node n) {
-    return !isNumericResult(n) && !isBooleanResult(n)
-        && !isUndefined(n) && !isNull(n);
+        return !isNumericResult(n) && !isBooleanResult(n) && !isUndefined(n) && !isNull(n);
   }
 
   /**
@@ -1438,8 +1330,7 @@
    * Is this a GETPROP or GETELEM node?
    */
   static boolean isGet(Node n) {
-    return n.getType() == Token.GETPROP
-        || n.getType() == Token.GETELEM;
+        return n.getType() == Token.GETPROP || n.getType() == Token.GETELEM;
   }
 
   /**
@@ -1513,8 +1404,7 @@
    *     first child is ASSIGN
    */
   static boolean isExprAssign(Node n) {
-    return n.getType() == Token.EXPR_RESULT
-        && n.getFirstChild().getType() == Token.ASSIGN;
+        return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.ASSIGN;
   }
 
   /**
@@ -1532,16 +1422,14 @@
    *     first child is CALL
    */
   static boolean isExprCall(Node n) {
-    return n.getType() == Token.EXPR_RESULT
-        && n.getFirstChild().getType() == Token.CALL;
+        return n.getType() == Token.EXPR_RESULT && n.getFirstChild().getType() == Token.CALL;
   }
 
   /**
    * @return Whether the node represents a FOR-IN loop.
    */
   static boolean isForIn(Node n) {
-    return n.getType() == Token.FOR
-        && n.getChildCount() == 3;
+        return n.getType() == Token.FOR && n.getChildCount() == 3;
   }
 
   /**
@@ -1584,7 +1472,6 @@
       if (NodeUtil.isLoopStructure(parent)) {
         return true;
       }
-
       if (NodeUtil.isFunction(parent)) {
         break;
       }
@@ -1699,7 +1586,9 @@
     }
   }
 
-  /** Whether the node is part of a switch statement. */
+    /**
+     * Whether the node is part of a switch statement.
+     */
   static boolean isSwitchCase(Node n) {
     return n.getType() == Token.CASE || n.getType() == Token.DEFAULT;
   }
@@ -1712,25 +1601,31 @@
     return isName(n) && !n.getString().isEmpty();
   }
 
-  /** @return Whether the node is a label name. */
+    /**
+     * @return Whether the node is a label name.
+     */
   static boolean isLabelName(Node n) {
     return (n != null && n.getType() == Token.LABEL_NAME);
   }
 
-  /** Whether the child node is the FINALLY block of a try. */
+    /**
+     * Whether the child node is the FINALLY block of a try.
+     */
   static boolean isTryFinallyNode(Node parent, Node child) {
-    return parent.getType() == Token.TRY && parent.getChildCount() == 3
-        && child == parent.getLastChild();
+        return parent.getType() == Token.TRY && parent.getChildCount() == 3 && child == parent.getLastChild();
   }
 
-  /** Whether the node is a CATCH container BLOCK. */
+    /**
+     * Whether the node is a CATCH container BLOCK.
+     */
   static boolean isTryCatchNodeContainer(Node n) {
     Node parent = n.getParent();
-    return parent.getType() == Token.TRY
-        && parent.getFirstChild().getNext() == n;
+        return parent.getType() == Token.TRY && parent.getFirstChild().getNext() == n;
   }
 
-  /** Safely remove children while maintaining a valid node structure. */
+    /**
+     * Safely remove children while maintaining a valid node structure.
+     */
   static void removeChild(Node parent, Node node) {
     if (isTryFinallyNode(parent, node)) {
       if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {
@@ -1755,8 +1650,7 @@
       // Simply empty the block.  This maintains source location and
       // "synthetic"-ness.
       node.detachChildren();
-    } else if (isStatementBlock(parent)
-        || isSwitchCase(node)) {
+        } else if (isStatementBlock(parent) || isSwitchCase(node)) {
       // A statement in a block can simply be removed.
       parent.removeChild(node);
     } else if (parent.getType() == Token.VAR) {
@@ -1768,21 +1662,18 @@
         // This would leave an empty VAR, remove the VAR itself.
         removeChild(parent.getParent(), parent);
       }
-    } else if (parent.getType() == Token.LABEL
-        && node == parent.getLastChild()) {
+        } else if (parent.getType() == Token.LABEL && node == parent.getLastChild()) {
       // Remove the node from the parent, so it can be reused.
       parent.removeChild(node);
       // A LABEL without children can not be referred to, remove it.
       removeChild(parent.getParent(), parent);
-    } else if (parent.getType() == Token.FOR
-        && parent.getChildCount() == 4) {
+        } else if (parent.getType() == Token.FOR && parent.getChildCount() == 4) {
       // Only Token.FOR can have an Token.EMPTY other control structure
       // need something for the condition. Others need to be replaced
       // or the structure removed.
       parent.replaceChild(node, new Node(Token.EMPTY));
     } else {
-      throw new IllegalStateException("Invalid attempt to remove node: " +
-          node.toString() + " of "+ parent.toString());
+            throw new IllegalStateException("Invalid attempt to remove node: " + node.toString() + " of " + parent.toString());
     }
   }
 
@@ -1792,8 +1683,7 @@
   static void maybeAddFinally(Node tryNode) {
     Preconditions.checkState(tryNode.getType() == Token.TRY);
     if (!NodeUtil.hasFinally(tryNode)) {
-      tryNode.addChildrenToBack(new Node(Token.BLOCK)
-          .copyInformationFrom(tryNode));
+            tryNode.addChildrenToBack(new Node(Token.BLOCK).copyInformationFrom(tryNode));
     }
   }
 
@@ -1857,7 +1747,6 @@
     return node.getType() == Token.THIS;
   }
 
-
   /**
    * Is this an ARRAYLIT node
    */
@@ -1887,9 +1776,7 @@
    * See {@link #isFunctionDeclaration}).
    */
   static boolean isHoistedFunctionDeclaration(Node n) {
-    return isFunctionDeclaration(n)
-        && (n.getParent().getType() == Token.SCRIPT
-            || n.getParent().getParent().getType() == Token.FUNCTION);
+        return isFunctionDeclaration(n) && (n.getParent().getType() == Token.SCRIPT || n.getParent().getParent().getType() == Token.FUNCTION);
   }
 
   /**
@@ -1935,10 +1822,7 @@
    */
   static boolean isVarArgsFunction(Node function) {
     Preconditions.checkArgument(isFunction(function));
-    return isNameReferenced(
-        function.getLastChild(),
-        "arguments",
-        new MatchNotFunction());
+        return isNameReferenced(function.getLastChild(), "arguments", new MatchNotFunction());
   }
 
   /**
@@ -1960,7 +1844,6 @@
     return false;
   }
 
-
   /**
    * @return Whether the callNode represents an expression in the form of:
    *    x.call(...)
@@ -2003,7 +1886,6 @@
         return true;
       }
     }
-
     return false;
   }
 
@@ -2017,8 +1899,7 @@
    * @return True if n is the left hand of an assign
    */
   static boolean isLhs(Node n, Node parent) {
-    return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) ||
-           parent.getType() == Token.VAR;
+        return (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) || parent.getType() == Token.VAR;
   }
 
   /**
@@ -2114,48 +1995,90 @@
    */
   static String opToStr(int operator) {
     switch (operator) {
-      case Token.BITOR: return "|";
-      case Token.OR: return "||";
-      case Token.BITXOR: return "^";
-      case Token.AND: return "&&";
-      case Token.BITAND: return "&";
-      case Token.SHEQ: return "===";
-      case Token.EQ: return "==";
-      case Token.NOT: return "!";
-      case Token.NE: return "!=";
-      case Token.SHNE: return "!==";
-      case Token.LSH: return "<<";
-      case Token.IN: return "in";
-      case Token.LE: return "<=";
-      case Token.LT: return "<";
-      case Token.URSH: return ">>>";
-      case Token.RSH: return ">>";
-      case Token.GE: return ">=";
-      case Token.GT: return ">";
-      case Token.MUL: return "*";
-      case Token.DIV: return "/";
-      case Token.MOD: return "%";
-      case Token.BITNOT: return "~";
-      case Token.ADD: return "+";
-      case Token.SUB: return "-";
-      case Token.POS: return "+";
-      case Token.NEG: return "-";
-      case Token.ASSIGN: return "=";
-      case Token.ASSIGN_BITOR: return "|=";
-      case Token.ASSIGN_BITXOR: return "^=";
-      case Token.ASSIGN_BITAND: return "&=";
-      case Token.ASSIGN_LSH: return "<<=";
-      case Token.ASSIGN_RSH: return ">>=";
-      case Token.ASSIGN_URSH: return ">>>=";
-      case Token.ASSIGN_ADD: return "+=";
-      case Token.ASSIGN_SUB: return "-=";
-      case Token.ASSIGN_MUL: return "*=";
-      case Token.ASSIGN_DIV: return "/=";
-      case Token.ASSIGN_MOD: return "%=";
-      case Token.VOID: return "void";
-      case Token.TYPEOF: return "typeof";
-      case Token.INSTANCEOF: return "instanceof";
-      default: return null;
+            case Token.BITOR:
+                return "|";
+            case Token.OR:
+                return "||";
+            case Token.BITXOR:
+                return "^";
+            case Token.AND:
+                return "&&";
+            case Token.BITAND:
+                return "&";
+            case Token.SHEQ:
+                return "===";
+            case Token.EQ:
+                return "==";
+            case Token.NOT:
+                return "!";
+            case Token.NE:
+                return "!=";
+            case Token.SHNE:
+                return "!==";
+            case Token.LSH:
+                return "<<";
+            case Token.IN:
+                return "in";
+            case Token.LE:
+                return "<=";
+            case Token.LT:
+                return "<";
+            case Token.URSH:
+                return ">>>";
+            case Token.RSH:
+                return ">>";
+            case Token.GE:
+                return ">=";
+            case Token.GT:
+                return ">";
+            case Token.MUL:
+                return "*";
+            case Token.DIV:
+                return "/";
+            case Token.MOD:
+                return "%";
+            case Token.BITNOT:
+                return "~";
+            case Token.ADD:
+                return "+";
+            case Token.SUB:
+                return "-";
+            case Token.POS:
+                return "+";
+            case Token.NEG:
+                return "-";
+            case Token.ASSIGN:
+                return "=";
+            case Token.ASSIGN_BITOR:
+                return "|=";
+            case Token.ASSIGN_BITXOR:
+                return "^=";
+            case Token.ASSIGN_BITAND:
+                return "&=";
+            case Token.ASSIGN_LSH:
+                return "<<=";
+            case Token.ASSIGN_RSH:
+                return ">>=";
+            case Token.ASSIGN_URSH:
+                return ">>>=";
+            case Token.ASSIGN_ADD:
+                return "+=";
+            case Token.ASSIGN_SUB:
+                return "-=";
+            case Token.ASSIGN_MUL:
+                return "*=";
+            case Token.ASSIGN_DIV:
+                return "/=";
+            case Token.ASSIGN_MOD:
+                return "%=";
+            case Token.VOID:
+                return "void";
+            case Token.TYPEOF:
+                return "typeof";
+            case Token.INSTANCEOF:
+                return "instanceof";
+            default:
+                return null;
     }
   }
 
@@ -2170,8 +2093,7 @@
   static String opToStrNoFail(int operator) {
     String res = opToStr(operator);
     if (res == null) {
-      throw new Error("Unknown op " + operator + ": " +
-                      Token.name(operator));
+            throw new Error("Unknown op " + operator + ": " + Token.name(operator));
     }
     return res;
   }
@@ -2179,9 +2101,7 @@
   /**
    * @return true if n or any of its children are of the specified type
    */
-  static boolean containsType(Node node,
-                              int type,
-                              Predicate<Node> traverseChildrenPred) {
+    static boolean containsType(Node node, int type, Predicate<Node> traverseChildrenPred) {
     return has(node, new MatchNodeType(type), traverseChildrenPred);
   }
 
@@ -2192,7 +2112,6 @@
     return containsType(node, type, Predicates.<Node>alwaysTrue());
   }
 
-
   /**
    * Given a node tree, finds all the VAR declarations in that tree that are
    * not in an inner scope. Then adds a new VAR node at the top of the current
@@ -2203,14 +2122,9 @@
     if (vars.isEmpty()) {
       return;
     }
-
     Node parent = getAddingRoot(branch);
     for (Node nameNode : vars) {
-      Node var = new Node(
-          Token.VAR,
-          Node.newString(Token.NAME, nameNode.getString())
-              .copyInformationFrom(nameNode))
-          .copyInformationFrom(nameNode);
+            Node var = new Node(Token.VAR, Node.newString(Token.NAME, nameNode.getString()).copyInformationFrom(nameNode)).copyInformationFrom(nameNode);
       copyNameAnnotations(nameNode, var.getFirstChild());
       parent.addChildToFront(var);
     }
@@ -2244,25 +2158,22 @@
         break;
       }
     }
-
     // make sure that the adding root looks ok
-    Preconditions.checkState(addingRoot.getType() == Token.BLOCK ||
-        addingRoot.getType() == Token.SCRIPT);
-    Preconditions.checkState(addingRoot.getFirstChild() == null ||
-        addingRoot.getFirstChild().getType() != Token.SCRIPT);
+        Preconditions.checkState(addingRoot.getType() == Token.BLOCK || addingRoot.getType() == Token.SCRIPT);
+        Preconditions.checkState(addingRoot.getFirstChild() == null || addingRoot.getFirstChild().getType() != Token.SCRIPT);
     return addingRoot;
   }
 
-  /** Creates function name(params_0, ..., params_n) { body }. */
-  public static Node newFunctionNode(String name, List<Node> params,
-      Node body, int lineno, int charno) {
+    /**
+     * Creates function name(params_0, ..., params_n) { body }.
+     */
+    public static Node newFunctionNode(String name, List<Node> params, Node body, int lineno, int charno) {
     Node parameterParen = new Node(Token.LP, lineno, charno);
     for (Node param : params) {
       parameterParen.addChildToBack(param);
     }
     Node function = new Node(Token.FUNCTION, lineno, charno);
-    function.addChildrenToBack(
-        Node.newString(Token.NAME, name, lineno, charno));
+        function.addChildrenToBack(Node.newString(Token.NAME, name, lineno, charno));
     function.addChildToBack(parameterParen);
     function.addChildToBack(body);
     return function;
@@ -2276,28 +2187,23 @@
    * @param charno The source character offset from start of the line.
    * @return A NAME or GETPROP node
    */
-  public static Node newQualifiedNameNode(
-      CodingConvention convention, String name, int lineno, int charno) {
+    public static Node newQualifiedNameNode(CodingConvention convention, String name, int lineno, int charno) {
     int endPos = name.indexOf('.');
     if (endPos == -1) {
       return newName(convention, name, lineno, charno);
     }
-    Node node = newName(
-        convention, name.substring(0, endPos), lineno, charno);
+        Node node = newName(convention, name.substring(0, endPos), lineno, charno);
     int startPos;
     do {
       startPos = endPos + 1;
       endPos = name.indexOf('.', startPos);
-      String part = (endPos == -1
-                     ? name.substring(startPos)
-                     : name.substring(startPos, endPos));
+            String part = (endPos == -1 ? name.substring(startPos) : name.substring(startPos, endPos));
       Node propNode = Node.newString(Token.STRING, part, lineno, charno);
       if (convention.isConstantKey(part)) {
         propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
       }
       node = new Node(Token.GETPROP, node, propNode, lineno, charno);
     } while (endPos != -1);
-
     return node;
   }
 
@@ -2314,9 +2220,7 @@
    *
    * @return A NAME or GETPROP node
    */
-  static Node newQualifiedNameNode(
-      CodingConvention convention, String name, Node basisNode,
-      String originalName) {
+    static Node newQualifiedNameNode(CodingConvention convention, String name, Node basisNode, String originalName) {
     Node node = newQualifiedNameNode(convention, name, -1, -1);
     setDebugInformation(node, basisNode, originalName);
     return node;
@@ -2326,8 +2230,7 @@
    * Gets the root node of a qualified name. Must be either NAME or THIS.
    */
   static Node getRootOfQualifiedName(Node qName) {
-    for (Node current = qName; true;
-         current = current.getFirstChild()) {
+        for (Node current = qName; true; current = current.getFirstChild()) {
       int type = current.getType();
       if (type == Token.NAME || type == Token.THIS) {
         return current;
@@ -2344,14 +2247,12 @@
    * @param basisNode The basis node from which to copy the source file info.
    * @param originalName The original name of the node.
    */
-  static void setDebugInformation(Node node, Node basisNode,
-                                  String originalName) {
+    static void setDebugInformation(Node node, Node basisNode, String originalName) {
     node.copyInformationFromForTree(basisNode);
     node.putProp(Node.ORIGINALNAME_PROP, originalName);
   }
 
-  private static Node newName(
-      CodingConvention convention, String name, int lineno, int charno) {
+    private static Node newName(CodingConvention convention, String name, int lineno, int charno) {
     Node nameNode = Node.newString(Token.NAME, name, lineno, charno);
     if (convention.isConstant(name)) {
       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
@@ -2369,8 +2270,7 @@
    *
    * @return The node created.
    */
-  static Node newName(
-      CodingConvention convention, String name, Node basisNode) {
+    static Node newName(CodingConvention convention, String name, Node basisNode) {
     Node nameNode = Node.newString(Token.NAME, name);
     if (convention.isConstantKey(name)) {
       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
@@ -2392,15 +2292,14 @@
    *
    * @return The node created.
    */
-  static Node newName(
-      CodingConvention convention, String name,
-      Node basisNode, String originalName) {
+    static Node newName(CodingConvention convention, String name, Node basisNode, String originalName) {
     Node nameNode = newName(convention, name, basisNode);
     nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);
     return nameNode;
   }
 
-  /** Test if all characters in the string are in the Basic Latin (aka ASCII)
+    /**
+     * Test if all characters in the string are in the Basic Latin (aka ASCII)
    * character set - that they have UTF-16 values equal to or below 0x7f.
    * This check can find which identifiers with Unicode characters need to be
    * escaped in order to allow resulting files to be processed by non-Unicode
@@ -2413,7 +2312,6 @@
    *
    * @return True if all characters in the string are in Basic Latin set.
    */
-
   static boolean isLatin(String s) {
     char LARGEST_BASIC_LATIN = 0x7f;
     int len = s.length();
@@ -2431,9 +2329,7 @@
    * the dot operator. Many properties (like reserved words) cannot.
    */
   static boolean isValidPropertyName(String name) {
-    return TokenStream.isJSIdentifier(name) &&
-        !TokenStream.isKeyword(name) &&
-        // no Unicode escaped characters - some browsers are less tolerant
+        return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && // no Unicode escaped characters - some browsers are less tolerant
         // of Unicode characters that might be valid according to the
         // language spec.
         // Note that by this point, unicode escapes have been converted
@@ -2443,6 +2339,7 @@
   }
 
   private static class VarCollector implements Visitor {
+
     final Map<String, Node> vars = Maps.newLinkedHashMap();
 
     public void visit(Node n) {
@@ -2463,10 +2360,7 @@
    */
   public static Collection<Node> getVarsDeclaredInBranch(Node root) {
     VarCollector collector = new VarCollector();
-    visitPreOrder(
-        root,
-        collector,
-        new MatchNotFunction());
+        visitPreOrder(root, collector, new MatchNotFunction());
     return collector.vars.values();
   }
 
@@ -2537,9 +2431,7 @@
       nodeName.addChildToBack(value);
       nodeName.copyInformationFrom(value);
     }
-    Node var = new Node(Token.VAR, nodeName)
-        .copyInformationFrom(nodeName);
-
+        Node var = new Node(Token.VAR, nodeName).copyInformationFrom(nodeName);
     return var;
   }
 
@@ -2547,6 +2439,7 @@
    * A predicate for matching name nodes with the specified node.
    */
   private static class MatchNameNode implements Predicate<Node>{
+
     final String name;
 
     MatchNameNode(String name){
@@ -2554,8 +2447,7 @@
     }
 
     public boolean apply(Node n) {
-      return n.getType() == Token.NAME
-          && n.getString().equals(name);
+            return n.getType() == Token.NAME && n.getString().equals(name);
     }
   }
 
@@ -2563,6 +2455,7 @@
    * A predicate for matching nodes with the specified type.
    */
   static class MatchNodeType implements Predicate<Node>{
+
     final int type;
 
     MatchNodeType(int type){
@@ -2574,11 +2467,11 @@
     }
   }
 
-
   /**
    * A predicate for matching var or function declarations.
    */
   static class MatchDeclaration implements Predicate<Node> {
+
     public boolean apply(Node n) {
       return isFunctionDeclaration(n) || n.getType() == Token.VAR;
     }
@@ -2588,6 +2481,7 @@
    * A predicate for matching anything except function nodes.
    */
   static class MatchNotFunction implements Predicate<Node>{
+
     public boolean apply(Node n) {
       return !isFunction(n);
     }
@@ -2597,29 +2491,24 @@
    * A predicate for matching statements without exiting the current scope.
    */
   static class MatchShallowStatement implements Predicate<Node>{
+
     public boolean apply(Node n) {
       Node parent = n.getParent();
-      return n.getType() == Token.BLOCK
-          || (!isFunction(n) && (parent == null
-              || isControlStructure(parent)
-              || isStatementBlock(parent)));
+            return n.getType() == Token.BLOCK || (!isFunction(n) && (parent == null || isControlStructure(parent) || isStatementBlock(parent)));
     }
   }
 
   /**
    * Finds the number of times a type is referenced within the node tree.
    */
-  static int getNodeTypeReferenceCount(
-      Node node, int type, Predicate<Node> traverseChildrenPred) {
+    static int getNodeTypeReferenceCount(Node node, int type, Predicate<Node> traverseChildrenPred) {
     return getCount(node, new MatchNodeType(type), traverseChildrenPred);
   }
 
   /**
    * Whether a simple name is referenced within the node tree.
    */
-  static boolean isNameReferenced(Node node,
-                                  String name,
-                                  Predicate<Node> traverseChildrenPred) {
+    static boolean isNameReferenced(Node node, String name, Predicate<Node> traverseChildrenPred) {
     return has(node, new MatchNameNode(name), traverseChildrenPred);
   }
 
@@ -2634,30 +2523,24 @@
    * Finds the number of times a simple name is referenced within the node tree.
    */
   static int getNameReferenceCount(Node node, String name) {
-    return getCount(
-        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());
+        return getCount(node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());
   }
 
   /**
    * @return Whether the predicate is true for the node or any of its children.
    */
-  static boolean has(Node node,
-                     Predicate<Node> pred,
-                     Predicate<Node> traverseChildrenPred) {
+    static boolean has(Node node, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {
     if (pred.apply(node)) {
       return true;
     }
-
     if (!traverseChildrenPred.apply(node)) {
       return false;
     }
-
     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
       if (has(c, pred, traverseChildrenPred)) {
         return true;
       }
     }
-
     return false;
   }
 
@@ -2665,20 +2548,16 @@
    * @return The number of times the the predicate is true for the node
    * or any of its children.
    */
-  static int getCount(
-      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {
+    static int getCount(Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {
     int total = 0;
-
     if (pred.apply(n)) {
       total++;
     }
-
     if (traverseChildrenPred.apply(n)) {
       for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
         total += getCount(c, pred, traverseChildrenPred);
       }
     }
-
     return total;
   }
 
@@ -2687,6 +2566,7 @@
    * @see #visit
    */
   static interface Visitor {
+
     void visit(Node node);
   }
 
@@ -2694,11 +2574,8 @@
    * A pre-order traversal, calling Vistor.visit for each child matching
    * the predicate.
    */
-  static void visitPreOrder(Node node,
-                     Visitor vistor,
-                     Predicate<Node> traverseChildrenPred) {
+    static void visitPreOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {
     vistor.visit(node);
-
     if (traverseChildrenPred.apply(node)) {
       for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
         visitPreOrder(c, vistor, traverseChildrenPred);
@@ -2710,15 +2587,12 @@
    * A post-order traversal, calling Vistor.visit for each child matching
    * the predicate.
    */
-  static void visitPostOrder(Node node,
-                     Visitor vistor,
-                     Predicate<Node> traverseChildrenPred) {
+    static void visitPostOrder(Node node, Visitor vistor, Predicate<Node> traverseChildrenPred) {
     if (traverseChildrenPred.apply(node)) {
       for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {
         visitPostOrder(c, vistor, traverseChildrenPred);
       }
     }
-
     vistor.visit(node);
   }
 
@@ -2779,12 +2653,12 @@
     return node.getBooleanProp(Node.IS_CONSTANT_NAME);
   }
 
-  /** Whether the given name is constant by coding convention. */
-  static boolean isConstantByConvention(
-      CodingConvention convention, Node node, Node parent) {
+    /**
+     * Whether the given name is constant by coding convention.
+     */
+    static boolean isConstantByConvention(CodingConvention convention, Node node, Node parent) {
     String name = node.getString();
-    if (parent.getType() == Token.GETPROP &&
-        node == parent.getLastChild()) {
+        if (parent.getType() == Token.GETPROP && node == parent.getLastChild()) {
       return convention.isConstantKey(name);
     } else if (isObjectLitKey(node, parent)) {
       return convention.isConstantKey(name);
@@ -2804,10 +2678,7 @@
       info = nameNode.getJSDocInfo();
       parent = nameNode.getParent();
     }
-
-    if (info == null && parent != null &&
-        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||
-          parent.getType() == Token.FUNCTION)) {
+        if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) {
       info = parent.getJSDocInfo();
     }
     return info;
@@ -2878,18 +2749,14 @@
         // A result that is aliased by a non-local name, is the effectively the
         // same as returning a non-local name, but this doesn't matter if the
         // value is immutable.
-        return NodeUtil.isImmutableValue(value.getLastChild())
-            || (locals.apply(value)
-                && evaluatesToLocalValue(value.getLastChild(), locals));
+                return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));
       case Token.COMMA:
         return evaluatesToLocalValue(value.getLastChild(), locals);
       case Token.AND:
       case Token.OR:
-        return evaluatesToLocalValue(value.getFirstChild(), locals)
-           && evaluatesToLocalValue(value.getLastChild(), locals);
+                return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
       case Token.HOOK:
-        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
-           && evaluatesToLocalValue(value.getLastChild(), locals);
+                return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);
       case Token.INC:
       case Token.DEC:
         if (value.getBooleanProp(Node.INCRDECR_PROP)) {
@@ -2906,12 +2773,9 @@
         // There is no information about the locality of object properties.
         return locals.apply(value);
       case Token.CALL:
-        return callHasLocalResult(value)
-            || isToStringMethodCall(value)
-            || locals.apply(value);
+                return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);
       case Token.NEW:
-        return newHasLocalResult(value)
-               || locals.apply(value);
+                return newHasLocalResult(value) || locals.apply(value);
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
@@ -2926,15 +2790,10 @@
         // Other op force a local value:
         //  x = '' + g (x is now an local string)
         //  x -= g (x is now an local number)
-        if (isAssignmentOp(value)
-            || isSimpleOperator(value)
-            || isImmutableValue(value)) {
+                if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {
           return true;
         }
-
-        throw new IllegalStateException(
-            "Unexpected expression node" + value +
-            "\n parent:" + value.getParent());
+                throw new IllegalStateException("Unexpected expression node" + value + "\n parent:" + value.getParent());
     }
   }
 
@@ -2958,8 +2817,7 @@
    */
   static Node getArgumentForFunction(Node function, int index) {
     Preconditions.checkState(isFunction(function));
-    return getNthSibling(
-        function.getFirstChild().getNext().getFirstChild(), index);
+        return getNthSibling(function.getFirstChild().getNext().getFirstChild(), index);
   }
 
   /**
@@ -2968,8 +2826,7 @@
    */
   static Node getArgumentForCallOrNew(Node call, int index) {
     Preconditions.checkState(isCallOrNew(call));
-    return getNthSibling(
-      call.getFirstChild().getNext(), index);
+        return getNthSibling(call.getFirstChild().getNext(), index);
   }
 
   private static boolean isToStringMethodCall(Node call) {

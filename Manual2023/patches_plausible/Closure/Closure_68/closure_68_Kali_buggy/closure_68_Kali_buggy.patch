diff -urwE '--exclude=*.patch' '--exclude=*.fix.java' /mnt/d4j_bug_info/buggyfiles/closure/closure_68_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java /mnt/D4JPatches/Manual2023/patches_plausible/Closure/Closure_68/closure_68_Kali_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
--- /mnt/d4j_bug_info/buggyfiles/closure/closure_68_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	2022-11-20 04:09:31.000000000 -0800
+++ /mnt/D4JPatches/Manual2023/patches_plausible/Closure/Closure_68/closure_68_Kali_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java	2023-11-13 22:37:06.000000000 -0800
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.google.javascript.jscomp.parsing;
 
 import com.google.common.base.Preconditions;
@@ -30,7 +29,6 @@
 import com.google.javascript.rhino.ScriptRuntime;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.JSDocInfo.Visibility;
-
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
@@ -38,16 +36,19 @@
 
 /**
  * A parser for JSDoc comments.
- *
  */
 // TODO(nicksantos): Unify all the JSDocInfo stuff into one package, instead of
 // spreading it across mutliple packages.
 public final class JsDocInfoParser {
 
   private final JsDocTokenStream stream;
+
   private final JSDocInfoBuilder jsdocBuilder;
+
   private final String sourceName;
+
   private final ErrorReporter errorReporter;
+
   private final ErrorReporterParser parser = new ErrorReporterParser();
 
   // Use a template node for properties set on all nodes to minimize the
@@ -55,41 +56,34 @@
   private final Node templateNode;
 
   private class ErrorReporterParser {
-    void addParserWarning(String messageId, String messageArg, int lineno,
-        int charno) {
-      errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),
-          sourceName, lineno, null, charno);
+
+        void addParserWarning(String messageId, String messageArg, int lineno, int charno) {
+            errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno);
     }
 
     void addParserWarning(String messageId, int lineno, int charno) {
-      errorReporter.warning(ScriptRuntime.getMessage0(messageId),
-          sourceName, lineno, null, charno);
+            errorReporter.warning(ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno);
     }
 
-    void addTypeWarning(String messageId, String messageArg, int lineno,
-                    int charno) {
-      errorReporter.warning(
-          "Bad type annotation. " +
-          ScriptRuntime.getMessage1(messageId, messageArg),
-          sourceName, lineno, null, charno);
+        void addTypeWarning(String messageId, String messageArg, int lineno, int charno) {
+            errorReporter.warning("Bad type annotation. " + ScriptRuntime.getMessage1(messageId, messageArg), sourceName, lineno, null, charno);
     }
 
     void addTypeWarning(String messageId, int lineno, int charno) {
-      errorReporter.warning(
-          "Bad type annotation. " +
-          ScriptRuntime.getMessage0(messageId),
-          sourceName, lineno, null, charno);
+            errorReporter.warning("Bad type annotation. " + ScriptRuntime.getMessage0(messageId), sourceName, lineno, null, charno);
     }
   }
 
   // The DocInfo with the fileoverview tag for the whole file.
   private JSDocInfo fileOverviewJSDocInfo = null;
+
   private State state;
 
   private final Map<String, Annotation> annotationNames;
+
   private final Set<String> suppressionNames;
-  static private final Set<String> modifiesAnnotationKeywords =
-      ImmutableSet.<String>of("this", "arguments");
+
+    static private final Set<String> modifiesAnnotationKeywords = ImmutableSet.<String>of("this", "arguments");
 
   private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;
 
@@ -100,8 +94,7 @@
    *
    * @param fileLevelJsDocBuilder
    */
-  void setFileLevelJsDocBuilder(
-      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
+    void setFileLevelJsDocBuilder(Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
     this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;
   }
 
@@ -114,16 +107,11 @@
   }
 
   private enum State {
-    SEARCHING_ANNOTATION,
-    SEARCHING_NEWLINE,
-    NEXT_IS_ANNOTATION
+
+        SEARCHING_ANNOTATION, SEARCHING_NEWLINE, NEXT_IS_ANNOTATION
   }
 
-  JsDocInfoParser(JsDocTokenStream stream,
-                  Comment commentNode,
-                  String sourceName,
-                  Config config,
-                  ErrorReporter errorReporter) {
+    JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, String sourceName, Config config, ErrorReporter errorReporter) {
     this.stream = stream;
     this.sourceName = sourceName;
     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);
@@ -132,7 +120,6 @@
     }
     this.annotationNames = config.annotationNames;
     this.suppressionNames = config.suppressionNames;
-
     this.errorReporter = errorReporter;
     this.templateNode = this.createTemplateNode();
   }
@@ -142,19 +129,8 @@
    * type if the parsing succeeded or {@code null} if it failed.
    */
   public static Node parseTypeString(String typeString) {
-    Config config = new Config(
-        Sets.<String>newHashSet(),
-        Sets.<String>newHashSet(),
-        false,
-        LanguageMode.ECMASCRIPT3,
-        false);
-    JsDocInfoParser parser = new JsDocInfoParser(
-        new JsDocTokenStream(typeString),
-        null,
-        "typeparsing",
-        config,
-        NullErrorReporter.forNewRhino());
-
+        Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false);
+        JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, "typeparsing", config, NullErrorReporter.forNewRhino());
     return parser.parseTopLevelTypeExpression(parser.next());
   }
 
@@ -169,17 +145,12 @@
   boolean parse() {
     int lineno;
     int charno;
-
     // JSTypes are represented as Rhino AST nodes, and then resolved later.
     JSTypeExpression type;
-
     state = State.SEARCHING_ANNOTATION;
     skipEOLs();
-
     JsDocToken token = next();
-
     List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
-
     // Always record that we have a comment.
     if (jsdocBuilder.shouldParseDocumentation()) {
       ExtractionInfo blockInfo = extractBlockComment(token);
@@ -188,14 +159,12 @@
         jsdocBuilder.recordBlockDescription(blockInfo.string);
       }
     } else {
-      if (token != JsDocToken.ANNOTATION &&
-          token != JsDocToken.EOC) {
+            if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
         // Mark that there was a description, but don't bother marking
         // what it was.
         jsdocBuilder.recordBlockDescription("");
       }
     }
-
     // Parse the actual JsDoc.
     retry: for (;;) {
       switch (token) {
@@ -204,25 +173,20 @@
             state = State.SEARCHING_NEWLINE;
             lineno = stream.getLineno();
             charno = stream.getCharno();
-
             String annotationName = stream.getString();
             Annotation annotation = annotationNames.get(annotationName);
             if (annotation == null) {
-              parser.addParserWarning("msg.bad.jsdoc.tag", annotationName,
-                  stream.getLineno(), stream.getCharno());
+                            parser.addParserWarning("msg.bad.jsdoc.tag", annotationName, stream.getLineno(), stream.getCharno());
             } else {
               // Mark the beginning of the annotation.
               jsdocBuilder.markAnnotation(annotationName, lineno, charno);
-
               switch (annotation) {
                 case AUTHOR:
                   if (jsdocBuilder.shouldParseDocumentation()) {
                     ExtractionInfo authorInfo = extractSingleLineBlock();
                     String author = authorInfo.string;
-
                     if (author.length() == 0) {
-                      parser.addParserWarning("msg.jsdoc.authormissing",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addParserWarning("msg.jsdoc.authormissing", stream.getLineno(), stream.getCharno());
                     } else {
                       jsdocBuilder.addAuthor(author);
                     }
@@ -231,160 +195,114 @@
                     token = eatTokensUntilEOL(token);
                   }
                   continue retry;
-
                 case CONSTANT:
                   if (!jsdocBuilder.recordConstancy()) {
-                    parser.addParserWarning("msg.jsdoc.const",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.const", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case CONSTRUCTOR:
                   if (!jsdocBuilder.recordConstructor()) {
                     if (jsdocBuilder.isInterfaceRecorded()) {
-                      parser.addTypeWarning("msg.jsdoc.interface.constructor",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addTypeWarning("msg.jsdoc.interface.constructor", stream.getLineno(), stream.getCharno());
                     } else {
-                      parser.addTypeWarning("msg.jsdoc.incompat.type",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addTypeWarning("msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno());
                     }
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case DEPRECATED:
                   if (!jsdocBuilder.recordDeprecated()) {
-                    parser.addParserWarning("msg.jsdoc.deprecated",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.deprecated", stream.getLineno(), stream.getCharno());
                   }
-
                   // Find the reason/description, if any.
-                  ExtractionInfo reasonInfo =
-                      extractMultilineTextualBlock(token);
-
+                                    ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                   String reason = reasonInfo.string;
-
                   if (reason.length() > 0) {
                     jsdocBuilder.recordDeprecationReason(reason);
                   }
-
                   token = reasonInfo.token;
                   continue retry;
-
                 case INTERFACE:
                   if (!jsdocBuilder.recordInterface()) {
                     if (jsdocBuilder.isConstructorRecorded()) {
-                      parser.addTypeWarning("msg.jsdoc.interface.constructor",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addTypeWarning("msg.jsdoc.interface.constructor", stream.getLineno(), stream.getCharno());
                     } else {
-                      parser.addTypeWarning("msg.jsdoc.incompat.type",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addTypeWarning("msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno());
                     }
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case DESC:
                   if (jsdocBuilder.isDescriptionRecorded()) {
-                    parser.addParserWarning("msg.jsdoc.desc.extra",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.desc.extra", stream.getLineno(), stream.getCharno());
                     token = eatTokensUntilEOL();
                     continue retry;
                   } else {
-                    ExtractionInfo descriptionInfo =
-                        extractMultilineTextualBlock(token);
-
+                                        ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                     String description = descriptionInfo.string;
-
                     jsdocBuilder.recordDescription(description);
                     token = descriptionInfo.token;
                     continue retry;
                   }
-
                 case FILE_OVERVIEW:
                   String fileOverview = "";
                   if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo fileOverviewInfo =
-                        extractMultilineTextualBlock(token,
-                            WhitespaceOption.TRIM);
-
+                                        ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                     fileOverview = fileOverviewInfo.string;
-
                     token = fileOverviewInfo.token;
                   } else {
                     token = eatTokensUntilEOL(token);
                   }
-
-                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||
-                      fileOverviewJSDocInfo != null) {
-                    parser.addParserWarning("msg.jsdoc.fileoverview.extra",
-                        stream.getLineno(), stream.getCharno());
+                                    if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
+                                        parser.addParserWarning("msg.jsdoc.fileoverview.extra", stream.getLineno(), stream.getCharno());
                   }
                   continue retry;
-
                 case LICENSE:
                 case PRESERVE:
-                  ExtractionInfo preserveInfo =
-                      extractMultilineTextualBlock(token,
-                                                   WhitespaceOption.PRESERVE);
-
+                                    ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                   String preserve = preserveInfo.string;
-
                   if (preserve.length() > 0) {
                     if (fileLevelJsDocBuilder != null) {
                       fileLevelJsDocBuilder.append(preserve);
                     }
                   }
-
                   token = preserveInfo.token;
                   continue retry;
-
                 case ENUM:
                   token = next();
                   lineno = stream.getLineno();
                   charno = stream.getCharno();
-
                   type = null;
                   if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
-                    type = createJSTypeExpression(
-                        parseAndRecordTypeNode(token));
+                                        type = createJSTypeExpression(parseAndRecordTypeNode(token));
                   }
-
                   if (type == null) {
                     type = createJSTypeExpression(newStringNode("number"));
                   }
                   if (!jsdocBuilder.recordEnumParameterType(type)) {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.incompat.type", lineno, charno);
+                                        parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
                   }
                   token = eatTokensUntilEOL(token);
                   continue retry;
-
                 case EXPORT:
                   if (!jsdocBuilder.recordExport()) {
-                    parser.addParserWarning("msg.jsdoc.export",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.export", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case EXTERNS:
                   if (!jsdocBuilder.recordExterns()) {
-                    parser.addParserWarning("msg.jsdoc.externs",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.externs", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case JAVA_DISPATCH:
                   if (!jsdocBuilder.recordJavaDispatch()) {
-                    parser.addParserWarning("msg.jsdoc.javadispatch",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.javadispatch", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case EXTENDS:
                 case IMPLEMENTS:
                   skipEOLs();
@@ -392,148 +310,111 @@
                   lineno = stream.getLineno();
                   charno = stream.getCharno();
                   boolean matchingRc = false;
-
                   if (token == JsDocToken.LC) {
                     token = next();
                     matchingRc = true;
                   }
-
                   if (token == JsDocToken.STRING) {
-                    Node typeNode = parseAndRecordTypeNameNode(
-                        token, lineno, charno, matchingRc);
-
+                                        Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                     lineno = stream.getLineno();
                     charno = stream.getCharno();
-
                     typeNode = wrapNode(Token.BANG, typeNode);
                     if (typeNode != null && !matchingRc) {
                       typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                     }
                     type = createJSTypeExpression(typeNode);
-
                     if (annotation == Annotation.EXTENDS) {
                       // record the extended type, check later
-                      extendedTypes.add(new ExtendedTypeInfo(
-                          type, stream.getLineno(), stream.getCharno()));
+                                            extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
                     } else {
-                      Preconditions.checkState(
-                          annotation == Annotation.IMPLEMENTS);
+                                            Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                       if (!jsdocBuilder.recordImplementedInterface(type)) {
-                        parser.addTypeWarning("msg.jsdoc.implements.duplicate",
-                            lineno, charno);
+                                                parser.addTypeWarning("msg.jsdoc.implements.duplicate", lineno, charno);
                       }
                     }
                     token = next();
                     if (matchingRc) {
                       if (token != JsDocToken.RC) {
-                        parser.addTypeWarning("msg.jsdoc.missing.rc",
-                            stream.getLineno(), stream.getCharno());
+                                                parser.addTypeWarning("msg.jsdoc.missing.rc", stream.getLineno(), stream.getCharno());
                       }
-                    } else if (token != JsDocToken.EOL &&
-                        token != JsDocToken.EOF && token != JsDocToken.EOC) {
-                      parser.addTypeWarning("msg.end.annotation.expected",
-                          stream.getLineno(), stream.getCharno());
+                                        } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
+                                            parser.addTypeWarning("msg.end.annotation.expected", stream.getLineno(), stream.getCharno());
                     }
                   } else {
                     parser.addTypeWarning("msg.no.type.name", lineno, charno);
                   }
                   token = eatTokensUntilEOL(token);
                   continue retry;
-
                 case HIDDEN:
                   if (!jsdocBuilder.recordHiddenness()) {
-                    parser.addParserWarning("msg.jsdoc.hidden",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.hidden", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case LENDS:
                   skipEOLs();
-
                   matchingRc = false;
                   if (match(JsDocToken.LC)) {
                     token = next();
                     matchingRc = true;
                   }
-
                   if (match(JsDocToken.STRING)) {
                     token = next();
                     if (!jsdocBuilder.recordLends(stream.getString())) {
-                      parser.addTypeWarning("msg.jsdoc.lends.incompatible",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addTypeWarning("msg.jsdoc.lends.incompatible", stream.getLineno(), stream.getCharno());
                     }
                   } else {
-                    parser.addTypeWarning("msg.jsdoc.lends.missing",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addTypeWarning("msg.jsdoc.lends.missing", stream.getLineno(), stream.getCharno());
                   }
-
                   if (matchingRc && !match(JsDocToken.RC)) {
-                    parser.addTypeWarning("msg.jsdoc.missing.rc",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addTypeWarning("msg.jsdoc.missing.rc", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case MEANING:
-                  ExtractionInfo meaningInfo =
-                      extractMultilineTextualBlock(token);
+                                    ExtractionInfo meaningInfo = extractMultilineTextualBlock(token);
                   String meaning = meaningInfo.string;
                   token = meaningInfo.token;
                   if (!jsdocBuilder.recordMeaning(meaning)) {
-                    parser.addParserWarning("msg.jsdoc.meaning.extra",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.meaning.extra", stream.getLineno(), stream.getCharno());
                   }
                   continue retry;
-
                 case NO_ALIAS:
                   if (!jsdocBuilder.recordNoAlias()) {
-                    parser.addParserWarning("msg.jsdoc.noalias",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.noalias", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case NO_COMPILE:
                   if (!jsdocBuilder.recordNoCompile()) {
-                    parser.addParserWarning("msg.jsdoc.nocompile",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.nocompile", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case NO_TYPE_CHECK:
                   if (!jsdocBuilder.recordNoTypeCheck()) {
-                    parser.addParserWarning("msg.jsdoc.nocheck",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.nocheck", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case NOT_IMPLEMENTED:
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case INHERIT_DOC:
                 case OVERRIDE:
                   if (!jsdocBuilder.recordOverride()) {
-                    parser.addTypeWarning("msg.jsdoc.override",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addTypeWarning("msg.jsdoc.override", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case THROWS:
                   skipEOLs();
                   token = next();
                   lineno = stream.getLineno();
                   charno = stream.getCharno();
                   type = null;
-
                   if (token == JsDocToken.LC) {
-                    type = createJSTypeExpression(
-                        parseAndRecordTypeNode(token));
-
+                                        type = createJSTypeExpression(parseAndRecordTypeNode(token));
                     if (type == null) {
                       // parsing error reported during recursive descent
                       // recovering parsing
@@ -541,41 +422,30 @@
                       continue retry;
                     }
                   }
-
                   // *Update* the token to that after the type annotation.
                   token = current();
-
                   // Save the throw type.
                   jsdocBuilder.recordThrowType(type);
-
                   // Find the throw's description (if applicable).
                   if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo descriptionInfo =
-                        extractMultilineTextualBlock(token);
-
+                                        ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                     String description = descriptionInfo.string;
-
                     if (description.length() > 0) {
                       jsdocBuilder.recordThrowDescription(type, description);
                     }
-
                     token = descriptionInfo.token;
                   } else {
                     token = eatTokensUntilEOL(token);
                   }
                   continue retry;
-
                 case PARAM:
                   skipEOLs();
                   token = next();
                   lineno = stream.getLineno();
                   charno = stream.getCharno();
                   type = null;
-
                   if (token == JsDocToken.LC) {
-                    type = createJSTypeExpression(
-                        parseAndRecordParamTypeNode(token));
-
+                                        type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                     if (type == null) {
                       // parsing error reported during recursive descent
                       // recovering parsing
@@ -587,22 +457,17 @@
                     lineno = stream.getLineno();
                     charno = stream.getCharno();
                   }
-
                   String name = null;
                   boolean isBracketedParam = JsDocToken.LB == token;
                   if (isBracketedParam) {
                     token = next();
                   }
-
                   if (JsDocToken.STRING != token) {
-                    parser.addTypeWarning("msg.missing.variable.name",
-                        lineno, charno);
+                                        parser.addTypeWarning("msg.missing.variable.name", lineno, charno);
                   } else {
                     name = stream.getString();
-
                     if (isBracketedParam) {
                       token = next();
-
                       // Throw out JsDocToolkit's "default" parameter
                       // annotation.  It makes no sense under our type
                       // system.
@@ -612,7 +477,6 @@
                           token = next();
                         }
                       }
-
                       if (JsDocToken.RB != token) {
                         reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
                       } else if (type != null) {
@@ -621,7 +485,6 @@
                         type = JSTypeExpression.makeOptionalArg(type);
                       }
                     }
-
                     // If the param name has a DOT in it, just throw it out
                     // quietly. We do not handle the JsDocToolkit method
                     // for handling properties of params.
@@ -629,155 +492,113 @@
                       name = null;
                     } else if (!jsdocBuilder.recordParameter(name, type)) {
                       if (jsdocBuilder.hasParameter(name)) {
-                        parser.addTypeWarning("msg.dup.variable.name", name,
-                            lineno, charno);
+                                                parser.addTypeWarning("msg.dup.variable.name", name, lineno, charno);
                       } else {
-                        parser.addTypeWarning("msg.jsdoc.incompat.type", name,
-                            lineno, charno);
+                                                parser.addTypeWarning("msg.jsdoc.incompat.type", name, lineno, charno);
                       }
                     }
                   }
-
                   if (name == null) {
                     token = eatTokensUntilEOL(token);
                     continue retry;
                   }
-
                   jsdocBuilder.markName(name, lineno, charno);
-
                   // Find the parameter's description (if applicable).
                   if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo paramDescriptionInfo =
-                        extractMultilineTextualBlock(token);
-
+                                        ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                     String paramDescription = paramDescriptionInfo.string;
-
                     if (paramDescription.length() > 0) {
-                      jsdocBuilder.recordParameterDescription(name,
-                          paramDescription);
+                                            jsdocBuilder.recordParameterDescription(name, paramDescription);
                     }
-
                     token = paramDescriptionInfo.token;
                   } else {
                     token = eatTokensUntilEOL(token);
                   }
                   continue retry;
-
                 case PRESERVE_TRY:
                   if (!jsdocBuilder.recordPreserveTry()) {
-                    parser.addParserWarning("msg.jsdoc.preservertry",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.preservertry", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case PRIVATE:
                   if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
-                    parser.addParserWarning("msg.jsdoc.visibility.private",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.visibility.private", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case PROTECTED:
                   if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
-                    parser.addParserWarning("msg.jsdoc.visibility.protected",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.visibility.protected", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case PUBLIC:
                   if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
-                    parser.addParserWarning("msg.jsdoc.visibility.public",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.visibility.public", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case NO_SHADOW:
                   if (!jsdocBuilder.recordNoShadow()) {
-                    parser.addParserWarning("msg.jsdoc.noshadow",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.noshadow", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case NO_SIDE_EFFECTS:
                   if (!jsdocBuilder.recordNoSideEffects()) {
-                    parser.addParserWarning("msg.jsdoc.nosideeffects",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.nosideeffects", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case MODIFIES:
                   token = parseModifiesTag(next());
                   continue retry;
-
                 case IMPLICIT_CAST:
                   if (!jsdocBuilder.recordImplicitCast()) {
-                    parser.addTypeWarning("msg.jsdoc.implicitcast",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addTypeWarning("msg.jsdoc.implicitcast", stream.getLineno(), stream.getCharno());
                   }
                   token = eatTokensUntilEOL();
                   continue retry;
-
                 case SEE:
                   if (jsdocBuilder.shouldParseDocumentation()) {
                     ExtractionInfo referenceInfo = extractSingleLineBlock();
                     String reference = referenceInfo.string;
-
                     if (reference.length() == 0) {
-                      parser.addParserWarning("msg.jsdoc.seemissing",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addParserWarning("msg.jsdoc.seemissing", stream.getLineno(), stream.getCharno());
                     } else {
                       jsdocBuilder.addReference(reference);
                     }
-
                     token = referenceInfo.token;
                   } else {
                     token = eatTokensUntilEOL(token);
                   }
                   continue retry;
-
                 case SUPPRESS:
                   token = parseSuppressTag(next());
                   continue retry;
-
                 case TEMPLATE:
                   ExtractionInfo templateInfo = extractSingleLineBlock();
                   String templateTypeName = templateInfo.string;
-
                   if (templateTypeName.length() == 0) {
-                    parser.addTypeWarning("msg.jsdoc.templatemissing",
-                          stream.getLineno(), stream.getCharno());
-                  } else if (!jsdocBuilder.recordTemplateTypeName(
-                      templateTypeName)) {
-                    parser.addTypeWarning("msg.jsdoc.template.at.most.once",
-                        stream.getLineno(), stream.getCharno());
+                                        parser.addTypeWarning("msg.jsdoc.templatemissing", stream.getLineno(), stream.getCharno());
+                                    } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
+                                        parser.addTypeWarning("msg.jsdoc.template.at.most.once", stream.getLineno(), stream.getCharno());
                   }
-
                   token = templateInfo.token;
                   continue retry;
-
                 case VERSION:
                   ExtractionInfo versionInfo = extractSingleLineBlock();
                   String version = versionInfo.string;
-
                   if (version.length() == 0) {
-                    parser.addParserWarning("msg.jsdoc.versionmissing",
-                          stream.getLineno(), stream.getCharno());
+                                        parser.addParserWarning("msg.jsdoc.versionmissing", stream.getLineno(), stream.getCharno());
                   } else {
                     if (!jsdocBuilder.recordVersion(version)) {
-                       parser.addParserWarning("msg.jsdoc.extraversion",
-                          stream.getLineno(), stream.getCharno());
+                                            parser.addParserWarning("msg.jsdoc.extraversion", stream.getLineno(), stream.getCharno());
                     }
                   }
-
                   token = versionInfo.token;
                   continue retry;
-
                 case DEFINE:
                 case RETURN:
                 case THIS:
@@ -785,10 +606,8 @@
                 case TYPEDEF:
                   lineno = stream.getLineno();
                   charno = stream.getCharno();
-
                   Node typeNode = null;
-                  if (!lookAheadForTypeAnnotation() &&
-                      annotation == Annotation.RETURN) {
+                                    if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
                     // If RETURN doesn't have a type annotation, record
                     // it as the unknown type.
                     typeNode = newNode(Token.QMARK);
@@ -797,7 +616,6 @@
                     token = next();
                     typeNode = parseAndRecordTypeNode(token, lineno, charno);
                   }
-
                   if (annotation == Annotation.THIS) {
                     typeNode = wrapNode(Token.BANG, typeNode);
                     if (typeNode != null && token != JsDocToken.LC) {
@@ -805,7 +623,6 @@
                     }
                   }
                   type = createJSTypeExpression(typeNode);
-
                   if (type == null) {
                     // error reported during recursive descent
                     // recovering parsing
@@ -813,59 +630,42 @@
                     switch (annotation) {
                       case DEFINE:
                         if (!jsdocBuilder.recordDefineType(type)) {
-                          parser.addParserWarning("msg.jsdoc.define",
-                              lineno, charno);
+                                                    parser.addParserWarning("msg.jsdoc.define", lineno, charno);
                         }
                         break;
-
                       case RETURN:
                         if (!jsdocBuilder.recordReturnType(type)) {
-                          parser.addTypeWarning(
-                              "msg.jsdoc.incompat.type", lineno, charno);
+                                                    parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
                           break;
                         }
-
                         // Find the return's description (if applicable).
                         if (jsdocBuilder.shouldParseDocumentation()) {
-                          ExtractionInfo returnDescriptionInfo =
-                              extractMultilineTextualBlock(token);
-
-                          String returnDescription =
-                              returnDescriptionInfo.string;
-
+                                                    ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
+                                                    String returnDescription = returnDescriptionInfo.string;
                           if (returnDescription.length() > 0) {
-                            jsdocBuilder.recordReturnDescription(
-                                returnDescription);
+                                                        jsdocBuilder.recordReturnDescription(returnDescription);
                           }
-
                           token = returnDescriptionInfo.token;
                         } else {
                           token = eatTokensUntilEOL(token);
                         }
                         continue retry;
-
                       case THIS:
                         if (!jsdocBuilder.recordThisType(type)) {
-                          parser.addTypeWarning(
-                              "msg.jsdoc.incompat.type", lineno, charno);
+                                                    parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
                         }
                         break;
-
                       case TYPE:
                         if (!jsdocBuilder.recordType(type)) {
-                          parser.addTypeWarning(
-                              "msg.jsdoc.incompat.type", lineno, charno);
+                                                    parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
                         }
                         break;
-
                       case TYPEDEF:
                         if (!jsdocBuilder.recordTypedef(type)) {
-                          parser.addTypeWarning(
-                              "msg.jsdoc.incompat.type", lineno, charno);
+                                                    parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
                         }
                         break;
                     }
-
                   token = eatTokensUntilEOL();
                   }
                   continue retry;
@@ -873,29 +673,29 @@
             }
           }
           break;
-
         case EOC:
           if (hasParsedFileOverviewDocInfo()) {
             fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
           }
           checkExtendedTypes(extendedTypes);
           return true;
-
         case EOF:
-          // discard any accumulated information
+                    {
+                        if (true)
+                            return true;
           jsdocBuilder.build(null);
-          parser.addParserWarning("msg.unexpected.eof",
-              stream.getLineno(), stream.getCharno());
+                    }
+                    parser.addParserWarning("msg.unexpected.eof", stream.getLineno(), stream.getCharno());
+                    checkExtendedTypes(extendedTypes);
+                    parser.addParserWarning("msg.unexpected.eof", stream.getLineno(), stream.getCharno());
           checkExtendedTypes(extendedTypes);
           return false;
-
         case EOL:
           if (state == State.SEARCHING_NEWLINE) {
             state = State.SEARCHING_ANNOTATION;
           }
           token = next();
           continue retry;
-
         default:
           if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
             token = next();
@@ -906,7 +706,6 @@
             continue retry;
           }
       }
-
       // next token
       token = next();
     }
@@ -917,13 +716,11 @@
       // If interface, record the multiple extended interfaces
       if (jsdocBuilder.isInterfaceRecorded()) {
         if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {
-          parser.addParserWarning("msg.jsdoc.extends.duplicate",
-              typeInfo.lineno, typeInfo.charno);
+                    parser.addParserWarning("msg.jsdoc.extends.duplicate", typeInfo.lineno, typeInfo.charno);
         }
       } else {
         if (!jsdocBuilder.recordBaseType(typeInfo.type)) {
-          parser.addTypeWarning("msg.jsdoc.incompat.type",
-              typeInfo.lineno, typeInfo.charno);
+                    parser.addTypeWarning("msg.jsdoc.incompat.type", typeInfo.lineno, typeInfo.charno);
         }
       }
     }
@@ -942,33 +739,26 @@
         if (match(JsDocToken.STRING)) {
           String name = stream.getString();
           if (!suppressionNames.contains(name)) {
-            parser.addParserWarning("msg.jsdoc.suppress.unknown", name,
-                stream.getLineno(), stream.getCharno());
+                        parser.addParserWarning("msg.jsdoc.suppress.unknown", name, stream.getLineno(), stream.getCharno());
           }
-
           suppressions.add(stream.getString());
           token = next();
         } else {
-          parser.addParserWarning("msg.jsdoc.suppress",
-              stream.getLineno(), stream.getCharno());
+                    parser.addParserWarning("msg.jsdoc.suppress", stream.getLineno(), stream.getCharno());
           return token;
         }
-
         if (match(JsDocToken.PIPE)) {
           token = next();
         } else {
           break;
         }
       }
-
       if (!match(JsDocToken.RC)) {
-        parser.addParserWarning("msg.jsdoc.suppress",
-            stream.getLineno(), stream.getCharno());
+                parser.addParserWarning("msg.jsdoc.suppress", stream.getLineno(), stream.getCharno());
       } else {
         token = next();
         if (!jsdocBuilder.recordSuppressions(suppressions)) {
-          parser.addParserWarning("msg.jsdoc.suppress.duplicate",
-              stream.getLineno(), stream.getCharno());
+                    parser.addParserWarning("msg.jsdoc.suppress.duplicate", stream.getLineno(), stream.getCharno());
         }
       }
     }
@@ -987,35 +777,27 @@
       while (true) {
         if (match(JsDocToken.STRING)) {
           String name = stream.getString();
-          if (!modifiesAnnotationKeywords.contains(name)
-              && !jsdocBuilder.hasParameter(name)) {
-              parser.addParserWarning("msg.jsdoc.modifies.unknown", name,
-                  stream.getLineno(), stream.getCharno());
+                    if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) {
+                        parser.addParserWarning("msg.jsdoc.modifies.unknown", name, stream.getLineno(), stream.getCharno());
           }
-
           modifies.add(stream.getString());
           token = next();
         } else {
-          parser.addParserWarning("msg.jsdoc.modifies",
-              stream.getLineno(), stream.getCharno());
+                    parser.addParserWarning("msg.jsdoc.modifies", stream.getLineno(), stream.getCharno());
           return token;
         }
-
         if (match(JsDocToken.PIPE)) {
           token = next();
         } else {
           break;
         }
       }
-
       if (!match(JsDocToken.RC)) {
-        parser.addParserWarning("msg.jsdoc.modifies",
-            stream.getLineno(), stream.getCharno());
+                parser.addParserWarning("msg.jsdoc.modifies", stream.getLineno(), stream.getCharno());
       } else {
         token = next();
         if (!jsdocBuilder.recordModifies(modifies)) {
-          parser.addParserWarning("msg.jsdoc.modifies.duplicate",
-              stream.getLineno(), stream.getCharno());
+                    parser.addParserWarning("msg.jsdoc.modifies.duplicate", stream.getLineno(), stream.getCharno());
         }
       }
     }
@@ -1042,8 +824,7 @@
    * @return The type expression found or null if none.
    */
   private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {
-    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),
-        matchingLC, false);
+        return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false);
   }
 
   /**
@@ -1055,10 +836,8 @@
    * @param startCharno The starting character position of the type expression.
    * @return The type expression found or null if none.
    */
-  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,
-      int startCharno) {
-    return parseAndRecordTypeNode(token, lineno, startCharno,
-        token == JsDocToken.LC, false);
+    private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno) {
+        return parseAndRecordTypeNode(token, lineno, startCharno, token == JsDocToken.LC, false);
   }
 
   /**
@@ -1071,8 +850,7 @@
    * @param matchingLC Whether the type expression starts with a "{".
    * @return The type expression found or null if none.
    */
-  private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,
-                                          int startCharno, boolean matchingLC) {
+    private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) {
     return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);
   }
 
@@ -1093,12 +871,9 @@
     Preconditions.checkArgument(token == JsDocToken.LC);
     int lineno = stream.getLineno();
     int startCharno = stream.getCharno();
-
     Node typeNode = parseParamTypeExpressionAnnotation(token);
     int endCharno = stream.getCharno();
-
-    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,
-        true);
+        jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, true);
     return typeNode;
   }
 
@@ -1115,27 +890,18 @@
    *     parseTypeExpressionAnnotation).
    * @return The type expression found or null if none.
    */
-  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,
-                                      int startCharno,
-                                      boolean matchingLC,
-                                      boolean onlyParseSimpleNames) {
+    private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) {
     Node typeNode = null;
-
     if (onlyParseSimpleNames) {
       typeNode = parseTypeNameAnnotation(token);
     } else {
       typeNode = parseTypeExpressionAnnotation(token);
     }
-
     if (typeNode != null && !matchingLC) {
       typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
     }
-
     int endCharno = stream.getCharno();
-
-    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,
-        matchingLC);
-
+        jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno, matchingLC);
     return typeNode;
   }
 
@@ -1146,58 +912,40 @@
     switch (token) {
       case ANNOTATION:
         return "@" + stream.getString();
-
       case BANG:
         return "!";
-
       case COMMA:
         return ",";
-
       case COLON:
         return ":";
-
       case GT:
         return ">";
-
       case LB:
         return "[";
-
       case LC:
         return "{";
-
       case LP:
         return "(";
-
       case LT:
         return ".<";
-
       case QMARK:
         return "?";
-
       case PIPE:
         return "|";
-
       case RB:
         return "]";
-
       case RC:
         return "}";
-
       case RP:
         return ")";
-
       case STAR:
         return "*";
-
       case ELLIPSIS:
         return "...";
-
       case EQUALS:
         return "=";
-
       case STRING:
         return stream.getString();
-
       default:
         throw new IllegalStateException(token.toString());
     }
@@ -1208,8 +956,7 @@
    * @param n A node. May be null.
    */
   private JSTypeExpression createJSTypeExpression(Node n) {
-    return n == null ? null :
-        new JSTypeExpression(n, sourceName);
+        return n == null ? null : new JSTypeExpression(n, sourceName);
   }
 
   /**
@@ -1218,7 +965,9 @@
    * methods.
    */
   private static class ExtractionInfo {
+
     private final String string;
+
     private final JsDocToken token;
 
     public ExtractionInfo(String string, JsDocToken token) {
@@ -1231,8 +980,11 @@
    * Tuple for recording extended types
    */
   private static class ExtendedTypeInfo {
+
     final JSTypeExpression type;
+
     final int lineno;
+
     final int charno;
 
     public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) {
@@ -1250,20 +1002,15 @@
    * @return The extraction information.
    */
   private ExtractionInfo extractSingleLineBlock() {
-
     // Get the current starting point.
     stream.update();
     int lineno = stream.getLineno();
     int charno = stream.getCharno() + 1;
-
     String line = stream.getRemainingJSDocLine().trim();
-
     // Record the textual description.
     if (line.length() > 0) {
-      jsdocBuilder.markText(line, lineno, charno, lineno,
-                            charno + line.length());
+            jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length());
     }
-
     return new ExtractionInfo(line, next());
   }
 
@@ -1272,16 +1019,19 @@
   }
 
   private enum WhitespaceOption {
+
     /**
      * Preserves all whitespace and formatting. Needed for licenses and
      * purposely formatted text.
      */
     PRESERVE,
-
-    /** Preserves newlines but trims the output. */
+        /**
+         * Preserves newlines but trims the output.
+         */
     TRIM,
-
-    /** Removes newlines and turns the output into a single line string. */
+        /**
+         * Removes newlines and turns the output into a single line string.
+         */
     SINGLE_LINE
   }
 
@@ -1299,32 +1049,23 @@
    * @return The extraction information.
    */
   @SuppressWarnings("fallthrough")
-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
-                                                      WhitespaceOption option) {
-
-    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
-        token == JsDocToken.EOF) {
+    private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
+        if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
       return new ExtractionInfo("", token);
     }
-
     stream.update();
     int startLineno = stream.getLineno();
     int startCharno = stream.getCharno() + 1;
-
     // Read the content from the first line.
     String line = stream.getRemainingJSDocLine();
     if (option != WhitespaceOption.PRESERVE) {
       line = line.trim();
     }
-
     StringBuilder builder = new StringBuilder();
     builder.append(line);
-
     state = State.SEARCHING_ANNOTATION;
     token = next();
-
     boolean ignoreStar = false;
-
     do {
       switch (token) {
         case STAR:
@@ -1332,71 +1073,52 @@
             if (builder.length() > 0) {
               builder.append(' ');
             }
-
             builder.append('*');
           }
-
           token = next();
           continue;
-
         case EOL:
           if (option != WhitespaceOption.SINGLE_LINE) {
             builder.append("\n");
           }
-
           ignoreStar = true;
           token = next();
           continue;
-
         case ANNOTATION:
         case EOC:
         case EOF:
           // When we're capturing a license block, annotations
           // in the block are ok.
-          if (!(option == WhitespaceOption.PRESERVE &&
-                token == JsDocToken.ANNOTATION)) {
+                    if (!(option == WhitespaceOption.PRESERVE && token == JsDocToken.ANNOTATION)) {
             String multilineText = builder.toString();
-
             if (option != WhitespaceOption.PRESERVE) {
               multilineText = multilineText.trim();
             }
-
             int endLineno = stream.getLineno();
             int endCharno = stream.getCharno();
-
             if (multilineText.length() > 0) {
-              jsdocBuilder.markText(multilineText, startLineno, startCharno,
-                  endLineno, endCharno);
+                            jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
             }
-
             return new ExtractionInfo(multilineText, token);
           }
-
           // FALL THROUGH
-
         default:
           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
-
           if (builder.length() > 0) {
             builder.append(' ');
           }
-
           builder.append(toString(token));
-
           line = stream.getRemainingJSDocLine();
-
           if (option != WhitespaceOption.PRESERVE) {
             line = trimEnd(line);
           }
-
           builder.append(line);
           token = next();
       }
     } while (true);
   }
 
-
   /**
    * Extracts the top-level block comment from the JsDoc comment, if any.
    * This method differs from the extractMultilineTextualBlock in that it
@@ -1410,43 +1132,33 @@
    */
   private ExtractionInfo extractBlockComment(JsDocToken token) {
     StringBuilder builder = new StringBuilder();
-
     boolean ignoreStar = true;
-
     do {
       switch (token) {
         case ANNOTATION:
         case EOC:
         case EOF:
           return new ExtractionInfo(builder.toString().trim(), token);
-
         case STAR:
           if (!ignoreStar) {
             if (builder.length() > 0) {
               builder.append(' ');
             }
-
             builder.append('*');
           }
-
           token = next();
           continue;
-
         case EOL:
           ignoreStar = true;
           builder.append('\n');
           token = next();
           continue;
-
         default:
           if (!ignoreStar && builder.length() > 0) {
             builder.append(' ');
           }
-
           ignoreStar = false;
-
           builder.append(toString(token));
-
           String line = stream.getRemainingJSDocLine();
           line = trimEnd(line);
           builder.append(line);
@@ -1475,7 +1187,6 @@
         break;
       }
     }
-
     if (trimCount == 0) {
       return s;
     }
@@ -1486,11 +1197,9 @@
   // http://wiki.ecmascript.org/doku.php?id=spec:spec
   // Deliberately written to line up with the actual grammar rules,
   // for maximum flexibility.
-
   // TODO(nicksantos): The current implementation tries to maintain backwards
   // compatibility with previous versions of the spec whenever we can.
   // We should try to gradually withdraw support for these.
-
   /**
    * TypeExpressionAnnotation := TypeExpression |
    *     '{' TopLevelTypeExpression '}'
@@ -1507,7 +1216,6 @@
           next();
         }
       }
-
       return typeNode;
     } else {
       return parseTypeExpression(token);
@@ -1525,9 +1233,7 @@
    */
   private Node parseParamTypeExpressionAnnotation(JsDocToken token) {
     Preconditions.checkArgument(token == JsDocToken.LC);
-
     skipEOLs();
-
     boolean restArg = false;
     token = next();
     if (token == JsDocToken.ELLIPSIS) {
@@ -1538,7 +1244,6 @@
       }
       restArg = true;
     }
-
     Node typeNode = parseTopLevelTypeExpression(token);
     if (typeNode != null) {
       skipEOLs();
@@ -1549,14 +1254,12 @@
         skipEOLs();
         typeNode = wrapNode(Token.EQUALS, typeNode);
       }
-
       if (!match(JsDocToken.RC)) {
         reportTypeSyntaxWarning("msg.jsdoc.missing.rc");
       } else {
         next();
       }
     }
-
     return typeNode;
   }
 
@@ -1575,7 +1278,6 @@
           next();
         }
       }
-
       return typeNode;
     } else {
       return parseTypeName(token);
@@ -1650,15 +1352,10 @@
       // I'm not a big fan of using look-ahead for this, but it makes
       // the type language a lot nicer.
       token = next();
-      if (token == JsDocToken.COMMA ||
-          token == JsDocToken.EQUALS ||
-          token == JsDocToken.RC ||
-          token == JsDocToken.RP ||
-          token == JsDocToken.PIPE) {
+            if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) {
         restoreLookAhead(token);
         return newNode(Token.QMARK);
       }
-
       return wrapNode(Token.QMARK, parseBasicTypeExpression(token));
     } else if (token == JsDocToken.BANG) {
       return wrapNode(Token.BANG, parseBasicTypeExpression(next()));
@@ -1673,7 +1370,6 @@
           return wrapNode(Token.BANG, basicTypeExpr);
         }
       }
-
       return basicTypeExpr;
     }
   }
@@ -1705,7 +1401,6 @@
         return parseTypeName(token);
       }
     }
-
     return reportGenericTypeSyntaxWarning();
   }
 
@@ -1718,31 +1413,25 @@
     if (token != JsDocToken.STRING) {
       return reportGenericTypeSyntaxWarning();
     }
-
     String typeName = stream.getString();
-    while (match(JsDocToken.EOL) &&
-        typeName.charAt(typeName.length() - 1) == '.') {
+        while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') {
       skipEOLs();
       if (match(JsDocToken.STRING)) {
         next();
         typeName += stream.getString();
       }
     }
-
     Node typeNameNode = newStringNode(typeName);
-
     if (match(JsDocToken.LT)) {
       next();
       skipEOLs();
       Node memberType = parseTypeExpressionList(next());
       if (memberType != null) {
         typeNameNode.addChildToFront(memberType);
-
         skipEOLs();
         if (!match(JsDocToken.GT)) {
           return reportTypeSyntaxWarning("msg.jsdoc.missing.gt");
         }
-
         next();
       }
     }
@@ -1760,13 +1449,11 @@
     if (token != JsDocToken.LP) {
       return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");
     }
-
     Node functionType = newNode(Token.FUNCTION);
     Node parameters = null;
     skipEOLs();
     if (!match(JsDocToken.RP)) {
       token = next();
-
       boolean hasParams = true;
       if (token == JsDocToken.STRING) {
         String tokenStr = stream.getString();
@@ -1776,18 +1463,14 @@
           if (match(JsDocToken.COLON)) {
             next();
             skipEOLs();
-            Node contextType = wrapNode(
-                isThis ? Token.THIS : Token.NEW,
-                parseTypeName(next()));
+                        Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));
             if (contextType == null) {
               return null;
             }
-
             functionType.addChildToFront(contextType);
           } else {
             return reportTypeSyntaxWarning("msg.jsdoc.missing.colon");
           }
-
           if (match(JsDocToken.COMMA)) {
             next();
             skipEOLs();
@@ -1797,7 +1480,6 @@
           }
         }
       }
-
       if (hasParams) {
         parameters = parseParametersType(token);
         if (parameters == null) {
@@ -1805,16 +1487,13 @@
         }
       }
     }
-
     if (parameters != null) {
       functionType.addChildToBack(parameters);
     }
-
     skipEOLs();
     if (!match(JsDocToken.RP)) {
       return reportTypeSyntaxWarning("msg.jsdoc.missing.rp");
     }
-
     skipEOLs();
     Node resultType = parseResultType(next());
     if (resultType == null) {
@@ -1859,7 +1538,6 @@
           skipEOLs();
           token = next();
         }
-
         if (token == JsDocToken.ELLIPSIS) {
           // In the latest ES4 proposal, there are no type constraints allowed
           // on variable arguments. We support the old syntax for backwards
@@ -1872,7 +1550,6 @@
             if (!match(JsDocToken.LB)) {
               return reportTypeSyntaxWarning("msg.jsdoc.missing.lb");
             }
-
             next();
             skipEOLs();
             paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));
@@ -1883,7 +1560,6 @@
             skipEOLs();
             next();
           }
-
           isVarArgs = true;
         } else {
           paramType = parseTypeExpression(token);
@@ -1893,7 +1569,6 @@
             paramType = wrapNode(Token.EQUALS, paramType);
           }
         }
-
         if (paramType == null) {
           return null;
         }
@@ -1903,13 +1578,10 @@
         }
       } while (match(JsDocToken.COMMA));
     }
-
     if (isVarArgs && match(JsDocToken.COMMA)) {
       return reportTypeSyntaxWarning("msg.jsdoc.function.varargs");
     }
-
     // The right paren will be checked by parseFunctionType
-
     return paramsType;
   }
 
@@ -1921,7 +1593,6 @@
     if (!match(JsDocToken.COLON)) {
       return newNode(Token.EMPTY);
     }
-
     token = next();
     skipEOLs();
     if (match(JsDocToken.STRING) && "void".equals(stream.getString())) {
@@ -1951,15 +1622,12 @@
     if (alternate != null) {
       union.addChildToBack(alternate);
     }
-
     Node expr = null;
     do {
       if (expr != null) {
         skipEOLs();
         token = next();
-        Preconditions.checkState(
-            token == JsDocToken.PIPE || token == JsDocToken.COMMA);
-
+                Preconditions.checkState(token == JsDocToken.PIPE || token == JsDocToken.COMMA);
         boolean isPipe = token == JsDocToken.PIPE;
         if (isPipe && match(JsDocToken.PIPE)) {
           // We support double pipes for backwards compatiblity.
@@ -1972,11 +1640,9 @@
       if (expr == null) {
         return null;
       }
-
       union.addChildToBack(expr);
       // We support commas for backwards compatiblity.
     } while (match(JsDocToken.PIPE, JsDocToken.COMMA));
-
     if (alternate == null) {
       skipEOLs();
       if (!match(JsDocToken.RP)) {
@@ -1996,7 +1662,6 @@
     Node array = newNode(Token.LB);
     Node arg = null;
     boolean hasVarArgs = false;
-
     do {
       if (arg != null) {
         next();
@@ -2009,18 +1674,15 @@
       } else {
         arg = parseTypeExpression(token);
       }
-
       if (arg == null) {
         return null;
       }
-
       array.addChildToBack(arg);
       if (hasVarArgs) {
         break;
       }
       skipEOLs();
     } while (match(JsDocToken.COMMA));
-
     if (!match(JsDocToken.RB)) {
       return reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
     }
@@ -2034,18 +1696,14 @@
   private Node parseRecordType(JsDocToken token) {
     Node recordType = newNode(Token.LC);
     Node fieldTypeList = parseFieldTypeList(token);
-
     if (fieldTypeList == null) {
       return reportGenericTypeSyntaxWarning();
     }
-
     skipEOLs();
     if (!match(JsDocToken.RC)) {
       return reportTypeSyntaxWarning("msg.jsdoc.missing.rc");
     }
-
     next();
-
     recordType.addChildToBack(fieldTypeList);
     return recordType;
   }
@@ -2055,29 +1713,22 @@
    */
   private Node parseFieldTypeList(JsDocToken token) {
     Node fieldTypeList = newNode(Token.LB);
-
     do {
       Node fieldType = parseFieldType(token);
-
       if (fieldType == null) {
         return null;
       }
-
       fieldTypeList.addChildToBack(fieldType);
-
       skipEOLs();
       if (!match(JsDocToken.COMMA)) {
         break;
       }
-
       // Move to the comma token.
       next();
-
       // Move to the token passed the comma.
       skipEOLs();
       token = next();
     } while (true);
-
     return fieldTypeList;
   }
 
@@ -2086,28 +1737,22 @@
    */
   private Node parseFieldType(JsDocToken token) {
     Node fieldName = parseFieldName(token);
-
     if (fieldName == null) {
       return null;
     }
-
     skipEOLs();
     if (!match(JsDocToken.COLON)) {
       return fieldName;
     }
-
     // Move to the colon.
     next();
-
     // Move to the token after the colon and parse
     // the type expression.
     skipEOLs();
     Node typeExpression = parseTypeExpression(next());
-
     if (typeExpression == null) {
       return null;
     }
-
     Node fieldType = newNode(Token.COLON);
     fieldType.addChildToBack(fieldName);
     fieldType.addChildToBack(typeExpression);
@@ -2123,26 +1768,21 @@
       case STRING:
         String string = stream.getString();
         return newStringNode(string);
-
       default:
         return null;
     }
   }
 
   private Node wrapNode(int type, Node n) {
-    return n == null ? null :
-        new Node(type, n, stream.getLineno(),
-            stream.getCharno()).clonePropsFrom(templateNode);
+        return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode);
   }
 
   private Node newNode(int type) {
-    return new Node(type, stream.getLineno(),
-        stream.getCharno()).clonePropsFrom(templateNode);
+        return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode);
   }
 
   private Node newStringNode(String s) {
-    return Node.newString(s, stream.getLineno(),
-        stream.getCharno()).clonePropsFrom(templateNode);
+        return Node.newString(s, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode);
   }
 
   // This is similar to IRFactory.createTemplateNode to share common props
@@ -2177,8 +1817,7 @@
    */
   private JsDocToken eatTokensUntilEOL(JsDocToken token) {
     do {
-      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||
-          token == JsDocToken.EOF) {
+            if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) {
         state = State.SEARCHING_ANNOTATION;
         return token;
       }
@@ -2196,7 +1835,9 @@
    */
   private JsDocToken unreadToken = NO_UNREAD_TOKEN;
 
-  /** Restores the lookahead token to the token stream */
+    /**
+     * Restores the lookahead token to the token stream
+     */
   private void restoreLookAhead(JsDocToken token) {
     unreadToken = token;
   }
